"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineImportStrategy = determineImportStrategy;
exports.default = void 0;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = require("path");

var _archiver = _interopRequireDefault(require("archiver"));

var _streams = require("@takeshape/streams");

var _chalk = _interopRequireDefault(require("chalk"));

var _log = _interopRequireDefault(require("../log"));

var _upload = require("../util/upload");

var _spin = _interopRequireDefault(require("../util/spin"));

var _graphql = require("../graphql");

var _login = require("./init/login");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-ignore
const startImport = (0, _graphql.graphQLQuery)(`
  mutation ($uri: String!, $name: String) {
    result: tsImportProject(uri: $uri, name: $name, origin: "@takeshape/cli")
  }
`);
const getImport = (0, _graphql.graphQLQuery)(`
  query ($importId: String!) {
    result: tsGetProjectImport(id: $importId) {
      id
      status
      message
      projectId
    }
  }
`);
const getUploadUrl = (0, _graphql.graphQLQuery)(`
  mutation ($filename: String!) {
    result: tsUploadProject(name: $filename, type: "application/zip", origin: "@takeshape/cli") {
      uri
      importId
    }
  }
`);

async function determineImportStrategy(path) {
  if (path.match(/^https?:\/\/.*/) !== null) return 'uri';
  if (path.match(/\.zip$/) !== null) return 'zip';
  await _fsExtra.default.access(path);
  if (_fsExtra.default.statSync(path).isDirectory()) return 'dir';
  throw Error('Unrecognized import path provided. Please provide a URI, zip path, or directory path');
}

async function listenForImportSuccess(client, importId) {
  // Spin until we get a 'success' message or it throws an error
  const spinQuery = getImport.bind(getImport, client, {
    importId
  });
  await (0, _spin.default)(spinQuery); // Return the ID of the project created by the import

  const {
    projectId
  } = await getImport(client, {
    importId
  });
  return projectId;
}

async function uploadZipFile(client, filename, filePath) {
  const {
    uri,
    importId
  } = await getUploadUrl(client, {
    filename
  });
  await (0, _upload.uploadFile)(filePath, uri);
  return importId;
}

function fatalError(message) {
  (0, _log.default)(_chalk.default.red('Error'), message);
  process.exit(1);
}
/*
tsg import

Import a project from a path or URL.
The user must be logged in.

Flags:
--from  Either a URI, zip file, or directory to import
--name  Provides a name for the newly imported project.
        Otherwise, the import will use the name in the pattern.yml file.
*/


var _default = async (command, params, flags) => {
  // we need to get a user token in order for the import to work
  if (!flags || !flags.from) return fatalError('No flags provided.');
  const authToken = await (0, _login.loginBrowser)(params);
  const client = (0, _graphql.createConnector)(params, authToken, '');

  try {
    const {
      from
    } = flags;
    const strategy = await determineImportStrategy(from);
    let importId;

    if (strategy === 'dir') {
      (0, _log.default)(`Zipping up ${from}…`);
      const dirName = (0, _path.basename)(from);
      const [zipPath] = (0, _upload.createTempFile)(`${dirName}.zip`);

      const output = _fsExtra.default.createWriteStream(zipPath);

      const archive = (0, _archiver.default)('zip');
      archive.directory(from, false);
      archive.finalize();
      await (0, _streams.pump)(archive, output);
      (0, _log.default)(`Starting import from ${dirName}.zip…\n`);
      importId = await uploadZipFile(client, `${dirName}.zip`, zipPath);
    }

    if (strategy === 'zip') {
      (0, _log.default)(`Starting import from ${from}…\n`);
      const fileName = (0, _path.basename)(from);
      importId = await uploadZipFile(client, fileName, from);
    }

    if (strategy === 'uri') {
      (0, _log.default)(`Starting import from ${from}…\n`);
      importId = await startImport(client, {
        uri: from,
        name: flags.name
      });
    }

    if (importId) {
      const projectId = await listenForImportSuccess(client, importId);
      (0, _log.default)(_chalk.default.green(`Success!`), `Created project ${projectId} from import.`);
      process.exit(0);
    }
  } catch (error) {
    return fatalError(error.message);
  }
};

exports.default = _default;