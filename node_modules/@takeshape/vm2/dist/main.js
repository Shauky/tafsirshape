/* eslint-disable global-require, no-use-before-define, max-len */

'use strict';

/**
 * This callback will be called to transform a script to JavaScript.
 *
 * @callback compileCallback
 * @param {string} code - Script code to transform to JavaScript.
 * @param {string} filename - Filename of this script.
 * @return {string} JavaScript code that represents the script code.
 */

/**
 * This callback will be called to resolve a module if it couldn't be found.
 *
 * @callback resolveCallback
 * @param {string} moduleName - Name of the module to resolve.
 * @param {string} dirname - Name of the current directory.
 * @return {(string|undefined)} The file or directory to use to load the requested module.
 */

const fs = require('fs');
const vm = require('vm');
const pa = require('path');
const {EventEmitter} = require('events');
const {INSPECT_MAX_BYTES} = require('buffer');
const helpers = require('./helpers.js');

/**
 * Load a script from a file and compile it.
 * 
 * @private
 * @param {string} filename - File name
 * @param {string} data - Script body
 * @param {string} prefix - Prefix for the script.
 * @param {string} suffix - Suffix for the script.
 * @return {vm.Script} The compiled script.
 */
function compileScript(filename, data, prefix, suffix) {
	return new vm.Script(prefix + data + suffix, {
		filename,
		displayErrors: false
	});
}

const contextifyJS = "/* global host */\n/* eslint-disable block-spacing, no-multi-spaces, brace-style, no-array-constructor, new-cap, no-use-before-define */\n\n'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst global = this;\n\nconst local = host.Object.create(null);\nlocal.Object = Object;\nlocal.Array = Array;\nlocal.Reflect = host.Object.create(null);\nlocal.Reflect.ownKeys = Reflect.ownKeys;\nlocal.Reflect.enumerable = Reflect.enumerate;\nlocal.Reflect.getPrototypeOf = Reflect.getPrototypeOf;\nlocal.Reflect.construct = Reflect.construct;\nlocal.Reflect.apply = Reflect.apply;\nlocal.Reflect.set = Reflect.set;\nlocal.Reflect.deleteProperty = Reflect.deleteProperty;\nlocal.Reflect.has = Reflect.has;\nlocal.Reflect.defineProperty = Reflect.defineProperty;\nlocal.Reflect.setPrototypeOf = Reflect.setPrototypeOf;\nlocal.Reflect.isExtensible = Reflect.isExtensible;\nlocal.Reflect.preventExtensions = Reflect.preventExtensions;\nlocal.Reflect.getOwnPropertyDescriptor = Reflect.getOwnPropertyDescriptor;\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nObject.setPrototypeOf(global, Object.prototype);\n\nObject.defineProperties(global, {\n\tglobal: {value: global},\n\tGLOBAL: {value: global},\n\troot: {value: global},\n\tisVM: {value: true}\n});\n\nconst DEBUG = false;\nconst OPNA = 'Operation not allowed on contextified object.';\nconst captureStackTrace = Error.captureStackTrace;\n\nconst FROZEN_TRAPS = host.Object.create(null);\nFROZEN_TRAPS.set = (target, key) => false;\nFROZEN_TRAPS.setPrototypeOf = (target, key) => false;\nFROZEN_TRAPS.defineProperty = (target, key) => false;\nFROZEN_TRAPS.deleteProperty = (target, key) => false;\nFROZEN_TRAPS.isExtensible = (target, key) => false;\nFROZEN_TRAPS.preventExtensions = (target) => false;\n\n// Map of contextified objects to original objects\nconst Contextified = new host.WeakMap();\nconst Decontextified = new host.WeakMap();\n\n// We can't use host's hasInstance method\nconst hasInstance = local.Object[Symbol.hasInstance];\nfunction instanceOf(value, construct) {\n\ttry {\n\t\treturn host.Reflect.apply(hasInstance, construct, [value]);\n\t} catch (ex) {\n\t\t// Never pass the handled exception through!\n\t\tthrow new VMError('Unable to perform instanceOf check.');\n\t\t// This exception actually never get to the user. It only instructs the caller to return null because we wasn't able to perform instanceOf check.\n\t}\n}\n\nconst SHARED_OBJECT = {__proto__: null};\n\nfunction createBaseObject(obj) {\n\tlet base;\n\tif (typeof obj === 'function') {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-new\n\t\t\tnew new host.Proxy(obj, {\n\t\t\t\t__proto__: null,\n\t\t\t\tconstruct() {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t})();\n\t\t\t// eslint-disable-next-line func-names\n\t\t\tbase = function() {};\n\t\t\tbase.prototype = null;\n\t\t} catch (e) {\n\t\t\tbase = () => {};\n\t\t}\n\t} else if (host.Array.isArray(obj)) {\n\t\tbase = [];\n\t} else {\n\t\treturn {__proto__: null};\n\t}\n\tif (!local.Reflect.setPrototypeOf(base, null)) {\n\t\t// Should not happen\n\t\treturn null;\n\t}\n\treturn base;\n}\n\n/**\n * VMError definition.\n */\n\nclass VMError extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tcaptureStackTrace(this, this.constructor);\n\t}\n}\n\nglobal.VMError = VMError;\n\n/*\n * This function will throw a TypeError for accessing properties\n * on a strict mode function\n */\nfunction throwCallerCalleeArgumentsAccess(key) {\n\t'use strict';\n\tthrowCallerCalleeArgumentsAccess[key];\n\treturn new VMError('Unreachable');\n}\n\nfunction unexpected() {\n\tthrow new VMError('Should not happen');\n}\n\nfunction doPreventExtensions(target, object, doProxy) {\n\tconst keys = local.Reflect.ownKeys(object);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tlet desc = local.Reflect.getOwnPropertyDescriptor(object, key);\n\t\tif (!desc) continue;\n\t\tif (!local.Reflect.setPrototypeOf(desc, null)) unexpected();\n\t\tif (!desc.configurable) {\n\t\t\tconst current = local.Reflect.getOwnPropertyDescriptor(target, key);\n\t\t\tif (current && !current.configurable) continue;\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc.get = doProxy(desc.get);\n\t\t\t\tdesc.set = doProxy(desc.set);\n\t\t\t} else {\n\t\t\t\tdesc.value = doProxy(desc.value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tdesc = {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumberable: desc.enumberable,\n\t\t\t\t\twriteable: true,\n\t\t\t\t\tvalue: null\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tdesc.value = null;\n\t\t\t}\n\t\t}\n\t\tif (!local.Reflect.defineProperty(target, key, desc)) unexpected();\n\t}\n\tif (!local.Reflect.preventExtensions(target)) unexpected();\n}\n\n/**\n * Decontextify.\n */\n\nconst Decontextify = host.Object.create(null);\nDecontextify.proxies = new host.WeakMap();\n\nDecontextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new host.Array();\n\n\ttry {\n\t\tconst arr = new host.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Decontextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new host.Array();\n\t}\n};\nDecontextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Decontextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Decontextify.object(instance, base, deepTraps, flags);\n};\nDecontextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Contextify.value(context);\n\n\t\t// Set context of all arguments to vm's context.\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Function;\n\t\t\tif (key === '__proto__') return host.Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Function.prototype;\n\t};\n\n\tproxy = Decontextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nDecontextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return host.Object;\n\t\t\tif (key === '__proto__') return host.Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return host.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return host.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return host.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return host.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Decontextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tvalue = Contextify.value(value);\n\n\t\ttry {\n\t\t\treturn local.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Decontextify.value(def.get) || undefined,\n\t\t\t\tset: Decontextify.value(def.set) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Decontextify.value(def.value),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Contextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Contextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Contextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = local.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success && descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new host.Error(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = local.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Contextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\n\thost.Object.assign(base, traps, deepTraps);\n\n\tlet shallow;\n\tif (host.Array.isArray(object)) {\n\t\tconst origGet = base.get;\n\t\tshallow = {\n\t\t\t__proto__: null,\n\t\t\townKeys: base.ownKeys,\n\t\t\t// TODO this get will call getOwnPropertyDescriptor of target all the time.\n\t\t\tget: origGet\n\t\t};\n\t\tbase.ownKeys = target => {\n\t\t\ttry {\n\t\t\t\tconst keys = local.Reflect.ownKeys(object);\n\t\t\t\t// Do this hack so that console.log(decontextify([1,2,3])) doesn't write the properties twice\n\t\t\t\t// a la [1,2,3,'0':1,'1':2,'2':3]\n\t\t\t\treturn Decontextify.value(keys.filter(key=>typeof key!=='string' || !key.match(/^\\d+$/)));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Decontextify.value(e);\n\t\t\t}\n\t\t};\n\t\tbase.get = (target, key, receiver) => {\n\t\t\tif (key === host.Symbol.toStringTag) return;\n\t\t\treturn origGet(target, key, receiver);\n\t\t};\n\t} else {\n\t\tshallow = SHARED_OBJECT;\n\t}\n\n\tconst proxy = new host.Proxy(createBaseObject(object), base);\n\tDecontextified.set(proxy, object);\n\t// We need two proxies since nodes inspect just removes one.\n\tconst proxy2 = new host.Proxy(proxy, shallow);\n\tDecontextify.proxies.set(object, proxy2);\n\tDecontextified.set(proxy2, object);\n\treturn proxy2;\n};\nDecontextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Contextified.has(value)) {\n\t\t\t// Contextified object has returned back from vm\n\t\t\treturn Contextified.get(value);\n\t\t} else if (Decontextify.proxies.has(value)) {\n\t\t\t// Decontextified proxy already exists, reuse\n\t\t\treturn Decontextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, Number))         { return Decontextify.instance(value, host.Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, String))         { return Decontextify.instance(value, host.String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, Boolean))        { return Decontextify.instance(value, host.Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, Date))           { return Decontextify.instance(value, host.Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, RangeError))     { return Decontextify.instance(value, host.RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, ReferenceError)) { return Decontextify.instance(value, host.ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, SyntaxError))    { return Decontextify.instance(value, host.SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, TypeError))      { return Decontextify.instance(value, host.TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, VMError))        { return Decontextify.instance(value, host.VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, EvalError))      { return Decontextify.instance(value, host.EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, URIError))       { return Decontextify.instance(value, host.URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Error))          { return Decontextify.instance(value, host.Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, Array))          { return Decontextify.instance(value, host.Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, RegExp))         { return Decontextify.instance(value, host.RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, Map))            { return Decontextify.instance(value, host.Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, WeakMap))        { return Decontextify.instance(value, host.WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, Set))            { return Decontextify.instance(value, host.Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, WeakSet))        { return Decontextify.instance(value, host.WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (Promise && instanceOf(value, Promise)) { return Decontextify.instance(value, host.Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (local.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Decontextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Decontextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Decontextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\n\n/**\n * Contextify.\n */\n\nconst Contextify = host.Object.create(null);\nContextify.proxies = new host.WeakMap();\n\nContextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new local.Array();\n\n\ttry {\n\t\tconst arr = new local.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Contextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new local.Array();\n\t}\n};\nContextify.instance = (instance, klass, deepTraps, flags, toStringTag) => {\n\tif (typeof instance === 'function') return Contextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (key === 'constructor') return klass;\n\t\t\tif (key === '__proto__') return klass.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\t\tif (key === host.Symbol.toStringTag && toStringTag) return toStringTag;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(instance, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Contextify.object(instance, base, deepTraps, flags);\n};\nContextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\t// eslint-disable-next-line prefer-const\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Decontextify.value(context);\n\n\t\t// Set context of all arguments to host's context.\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new Array(args[0]).fill(0);\n\t\t}\n\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Function;\n\t\t\tif (key === '__proto__') return Function.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\tif (key === 'caller' || key === 'callee' || key === 'arguments') throw throwCallerCalleeArgumentsAccess(key);\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(fnc, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn Function.prototype;\n\t};\n\n\tproxy = Contextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nContextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\ttry {\n\t\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\t\tif (key === 'isVMProxy') return true;\n\t\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\t\tif (key === 'constructor') return Object;\n\t\t\tif (key === '__proto__') return Object.prototype;\n\t\t} catch (e) {\n\t\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\t\treturn null;\n\t\t}\n\n\t\tif (key === '__defineGetter__') return local.Object.prototype.__defineGetter__;\n\t\tif (key === '__defineSetter__') return local.Object.prototype.__defineSetter__;\n\t\tif (key === '__lookupGetter__') return local.Object.prototype.__lookupGetter__;\n\t\tif (key === '__lookupSetter__') return local.Object.prototype.__lookupSetter__;\n\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.get(object, key), null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tif (key === '__proto__') return false;\n\t\tif (flags && flags.protected && typeof value === 'function') return false;\n\n\t\tvalue = Decontextify.value(value);\n\n\t\ttry {\n\t\t\treturn host.Reflect.set(object, key, value);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tlet desc;\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tget: Contextify.value(def.get, null, deepTraps, flags) || undefined,\n\t\t\t\tset: Contextify.value(def.set, null, deepTraps, flags) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\tdesc = {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: Contextify.value(def.value, null, deepTraps, flags),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t\tif (!desc.configurable) {\n\t\t\ttry {\n\t\t\t\tdef = host.Object.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!def || def.configurable) {\n\t\t\t\t\tlocal.Reflect.defineProperty(target, prop, desc);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen.\n\t\t\t}\n\t\t}\n\t\treturn desc;\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\tlet success = false;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.setPrototypeOf(descriptor, null);\n\t\t} catch (e) {\n\t\t\t// Should not happen\n\t\t}\n\t\tif (!success) return false;\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tconst descGet = descriptor.get;\n\t\tconst descSet = descriptor.set;\n\t\tconst descValue = descriptor.value;\n\n\t\tif (flags && flags.protected) {\n\t\t\tif (descGet || descSet || typeof descValue === 'function') return false;\n\t\t}\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descGet || descSet) {\n\t\t\tpropertyDescriptor.get = Decontextify.value(descGet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Decontextify.value(descSet, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Decontextify.value(descValue, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\tsuccess = host.Reflect.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success && descriptor.configurable) {\n\t\t\ttry {\n\t\t\t\tlocal.Reflect.defineProperty(target, key, descriptor);\n\t\t\t} catch (e) {\n\t\t\t\t// This should not happen.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.deleteProperty = (target, prop) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.deleteProperty(object, prop));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn local.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new VMError(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.has(object, key));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\tlet result;\n\t\ttry {\n\t\t\tresult = host.Reflect.isExtensible(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (!result) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\tlet success;\n\t\ttry {\n\t\t\tsuccess = local.Reflect.preventExtensions(object);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t\tif (success) {\n\t\t\ttry {\n\t\t\t\tif (local.Reflect.isExtensible(target)) {\n\t\t\t\t\tdoPreventExtensions(target, object, obj => Decontextify.value(obj, null, deepTraps, flags));\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// Should not happen\n\t\t\t}\n\t\t}\n\t\treturn success;\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(createBaseObject(object), host.Object.assign(base, traps, deepTraps));\n\tContextify.proxies.set(object, proxy);\n\tContextified.set(proxy, object);\n\treturn proxy;\n};\nContextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Decontextified.has(value)) {\n\t\t\t// Decontextified object has returned back to vm\n\t\t\treturn Decontextified.get(value);\n\t\t} else if (Contextify.proxies.has(value)) {\n\t\t\t// Contextified proxy already exists, reuse\n\t\t\treturn Contextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, host.Number))         { return Contextify.instance(value, Number, deepTraps, flags, 'Number');\n\t\t\t\t} else if (instanceOf(value, host.String))         { return Contextify.instance(value, String, deepTraps, flags, 'String');\n\t\t\t\t} else if (instanceOf(value, host.Boolean))        { return Contextify.instance(value, Boolean, deepTraps, flags, 'Boolean');\n\t\t\t\t} else if (instanceOf(value, host.Date))           { return Contextify.instance(value, Date, deepTraps, flags, 'Date');\n\t\t\t\t} else if (instanceOf(value, host.RangeError))     { return Contextify.instance(value, RangeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.ReferenceError)) { return Contextify.instance(value, ReferenceError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.SyntaxError))    { return Contextify.instance(value, SyntaxError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.TypeError))      { return Contextify.instance(value, TypeError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.VMError))        { return Contextify.instance(value, VMError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.EvalError))      { return Contextify.instance(value, EvalError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.URIError))       { return Contextify.instance(value, URIError, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Error))          { return Contextify.instance(value, Error, deepTraps, flags, 'Error');\n\t\t\t\t} else if (instanceOf(value, host.Array))          { return Contextify.instance(value, Array, deepTraps, flags, 'Array');\n\t\t\t\t} else if (instanceOf(value, host.RegExp))         { return Contextify.instance(value, RegExp, deepTraps, flags, 'RegExp');\n\t\t\t\t} else if (instanceOf(value, host.Map))            { return Contextify.instance(value, Map, deepTraps, flags, 'Map');\n\t\t\t\t} else if (instanceOf(value, host.WeakMap))        { return Contextify.instance(value, WeakMap, deepTraps, flags, 'WeakMap');\n\t\t\t\t} else if (instanceOf(value, host.Set))            { return Contextify.instance(value, Set, deepTraps, flags, 'Set');\n\t\t\t\t} else if (instanceOf(value, host.WeakSet))        { return Contextify.instance(value, WeakSet, deepTraps, flags, 'WeakSet');\n\t\t\t\t} else if (instanceOf(value, host.Promise))        { return Contextify.instance(value, Promise, deepTraps, flags, 'Promise');\n\t\t\t\t} else if (instanceOf(value, host.Buffer))         { return Contextify.instance(value, LocalBuffer, deepTraps, flags, 'Uint8Array');\n\t\t\t\t} else if (host.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Contextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Contextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Contextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\nContextify.setGlobal = (name, value) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\tglobal[prop] = Contextify.value(value);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.getGlobal = (name) => {\n\tconst prop = Contextify.value(name);\n\ttry {\n\t\treturn Decontextify.value(global[prop]);\n\t} catch (e) {\n\t\tthrow Decontextify.value(e);\n\t}\n};\nContextify.readonly = (value, mock) => {\n\treturn Contextify.value(value, null, FROZEN_TRAPS, null, mock);\n};\nContextify.protected = (value, mock) => {\n\treturn Contextify.value(value, null, null, {protected: true}, mock);\n};\nContextify.connect = (outer, inner) => {\n\tDecontextified.set(outer, inner);\n\tContextified.set(inner, outer);\n};\nContextify.makeModule = ()=>({exports: {}});\n\nconst BufferMock = host.Object.create(null);\nBufferMock.allocUnsafe = function allocUnsafe(size) {\n\treturn this.alloc(size);\n};\nBufferMock.allocUnsafeSlow = function allocUnsafeSlow(size) {\n\treturn this.alloc(size);\n};\nconst BufferOverride = host.Object.create(null);\nBufferOverride.inspect = function inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n};\nconst LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, BufferMock);\nContextify.connect(host.Buffer.prototype.inspect, BufferOverride.inspect);\n\n\nconst exportsMap = host.Object.create(null);\nexportsMap.Contextify = Contextify;\nexportsMap.Decontextify = Decontextify;\nexportsMap.Buffer = LocalBuffer;\nexportsMap.sandbox = Decontextify.value(global);\n\nreturn exportsMap;\n";
const fixAsyncJS = "'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst {GeneratorFunction, AsyncFunction, AsyncGeneratorFunction, global, Contextify, host} = this;\n// eslint-disable-next-line no-shadow\nconst {Function, eval: eval_, Promise, Object, Reflect, RegExp, VMError} = global;\nconst {setPrototypeOf, getOwnPropertyDescriptor, defineProperty} = Object;\nconst {apply: rApply, construct: rConstruct} = Reflect;\nconst {test} = RegExp.prototype;\n\nfunction rejectAsync() {\n\tthrow new VMError('Async not available');\n}\n\nconst testAsync = setPrototypeOf(/\\basync\\b/, null);\n\nfunction checkAsync(source) {\n\t// Filter async functions, await can only be in them.\n\tif (rApply(test, testAsync, [source])) {\n\t\tthrow rejectAsync();\n\t}\n\treturn source;\n}\n\nconst AsyncCheckHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tlet i;\n\t\tfor (i=0; i<args.length; i++) {\n\t\t\t// We want a exception here if args[i] is a Symbol\n\t\t\t// since Function does the same thing\n\t\t\targs[i] = checkAsync('' + args[i]);\n\t\t}\n\t\treturn rApply(target, undefined, args);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tlet i;\n\t\tfor (i=0; i<args.length; i++) {\n\t\t\t// We want a exception here if args[i] is a Symbol\n\t\t\t// since Function does the same thing\n\t\t\targs[i] = checkAsync('' + args[i]);\n\t\t}\n\t\treturn rConstruct(target, args);\n\t}\n};\n\nconst AsyncEvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tconst script = args[0];\n\t\tif (typeof script !== 'string') {\n\t\t\t// Eval does the same thing\n\t\t\treturn script;\n\t\t}\n\t\tcheckAsync(script);\n\t\treturn eval_(script);\n\t}\n};\n\nfunction override(obj, prop, value) {\n\tconst desc = getOwnPropertyDescriptor(obj, prop);\n\tdesc.value = value;\n\tdefineProperty(obj, prop, desc);\n}\n\nconst proxiedFunction = new host.Proxy(Function, AsyncCheckHandler);\noverride(Function.prototype, 'constructor', proxiedFunction);\nif (GeneratorFunction) {\n\tObject.setPrototypeOf(GeneratorFunction, proxiedFunction);\n\toverride(GeneratorFunction.prototype, 'constructor', new host.Proxy(GeneratorFunction, AsyncCheckHandler));\n}\nif (AsyncFunction || AsyncGeneratorFunction) {\n\tconst AsyncFunctionRejectHandler = {\n\t\t__proto__: null,\n\t\tapply: rejectAsync,\n\t\tconstruct: rejectAsync\n\t};\n\tif (AsyncFunction) {\n\t\tObject.setPrototypeOf(AsyncFunction, proxiedFunction);\n\t\toverride(AsyncFunction.prototype, 'constructor', new host.Proxy(AsyncFunction, AsyncFunctionRejectHandler));\n\t}\n\tif (AsyncGeneratorFunction) {\n\t\tObject.setPrototypeOf(AsyncGeneratorFunction, proxiedFunction);\n\t\toverride(AsyncGeneratorFunction.prototype, 'constructor', new host.Proxy(AsyncGeneratorFunction, AsyncFunctionRejectHandler));\n\t}\n}\n\nglobal.Function = Function.prototype.constructor;\nglobal.eval = new host.Proxy(eval_, AsyncEvalHandler);\n\nif (Promise) {\n\tconst AsyncRejectHandler = {\n\t\t__proto__: null,\n\t\tapply: rejectAsync\n\t};\n\n\tPromise.prototype.then = new host.Proxy(Promise.prototype.then, AsyncRejectHandler);\n\tContextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\tif (Promise.prototype.finally) {\n\t\tPromise.prototype.finally = new host.Proxy(Promise.prototype.finally, AsyncRejectHandler);\n\t\tContextify.connect(host.Promise.prototype.finally, Promise.prototype.finally);\n\t}\n\tif (Promise.prototype.catch) {\n\t\tPromise.prototype.catch = new host.Proxy(Promise.prototype.catch, AsyncRejectHandler);\n\t\tContextify.connect(host.Promise.prototype.catch, Promise.prototype.catch);\n\t}\n\n}\n";
const sandboxJS = "/* eslint-disable no-shadow, no-invalid-this */\n/* global vm, host, Contextify, Decontextify, VMError */\n\n'use strict';\n\nconst {Script} = host.require('vm');\nconst fs = host.require('fs');\nconst pa = host.require('path');\n\nconst BUILTIN_MODULES = host.process.binding('natives');\nconst parseJSON = JSON.parse;\n\n/**\n * @param {Object} host Hosts's internal objects.\n */\n\nreturn ((vm, host) => {\n\t'use strict';\n\n\tconst global = this;\n\n\tconst TIMERS = new host.WeakMap(); // Contains map of timers created inside sandbox\n\tconst BUILTINS = {};\n\tconst CACHE = {};\n\tconst EXTENSIONS = {\n\t\t['.json'](module, filename) {\n\t\t\ttry {\n\t\t\t\tconst code = fs.readFileSync(filename, 'utf8');\n\t\t\t\tmodule.exports = parseJSON(code);\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\t['.node'](module, filename) {\n\t\t\tif (vm.options.require.context === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\n\t\t\ttry {\n\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\tconst ext = vm.options.sourceExtensions[i];\n\n\t\tEXTENSIONS['.' + ext] = (module, filename, dirname) => {\n\t\t\tif (vm.options.require.context !== 'sandbox') {\n\t\t\t\ttry {\n\t\t\t\t\tmodule.exports = Contextify.readonly(host.require(filename));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow Contextify.value(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet closure;\n\n\t\t\t\ttry {\n\t\t\t\t\t// Load module\n\t\t\t\t\tlet contents = fs.readFileSync(filename, 'utf8');\n\t\t\t\t\tcontents = vm._compiler(contents, filename);\n\n\t\t\t\t\tconst code = `(function (exports, require, module, __filename, __dirname) { 'use strict'; ${contents} \\n});`;\n\n\t\t\t\t\t// Precompile script\n\t\t\t\t\tconst script = new Script(code, {\n\t\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\t\tdisplayErrors: false\n\t\t\t\t\t});\n\n\t\t\t\t\tclosure = script.runInContext(global, {\n\t\t\t\t\t\tfilename: filename || 'vm.js',\n\t\t\t\t\t\tdisplayErrors: false\n\t\t\t\t\t});\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tthrow Contextify.value(ex);\n\t\t\t\t}\n\n\t\t\t\t// run the script\n\t\t\t\tclosure(module.exports, module.require, module, filename, dirname);\n\t\t\t}\n\t\t};\n\t}\n\n\tconst _parseExternalOptions = (options) => {\n\t\tif (Array.isArray(options)) {\n\t\t\treturn {\n\t\t\t\texternal: options,\n\t\t\t\ttransitive: false\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\texternal: options.modules,\n\t\t\ttransitive: options.transitive\n\t\t};\n\t};\n\n\t/**\n\t * Resolve filename.\n\t */\n\n\tconst _resolveFilename = (path) => {\n\t\tif (!path) return null;\n\t\tpath = pa.resolve(path);\n\n\t\tconst exists = fs.existsSync(path);\n\t\tconst isdir = exists ? fs.statSync(path).isDirectory() : false;\n\n\t\t// direct file match\n\t\tif (exists && !isdir) return path;\n\n\t\t// load as file\n\n\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\tif (fs.existsSync(`${path}.${ext}`)) return `${path}.${ext}`;\n\t\t}\n\t\tif (fs.existsSync(`${path}.json`)) return `${path}.json`;\n\t\tif (fs.existsSync(`${path}.node`)) return `${path}.node`;\n\n\t\t// load as module\n\n\t\tif (fs.existsSync(`${path}/package.json`)) {\n\t\t\tlet pkg;\n\t\t\ttry {\n\t\t\t\tpkg = JSON.parse(fs.readFileSync(`${path}/package.json`, 'utf8'));\n\t\t\t} catch (ex) {\n\t\t\t\tthrow new VMError(`Module '${path}' has invalid package.json`, 'EMODULEINVALID');\n\t\t\t}\n\n\t\t\tlet main;\n\t\t\tif (pkg && pkg.main) {\n\t\t\t\tmain = _resolveFilename(`${path}/${pkg.main}`);\n\t\t\t\tif (!main) main = _resolveFilename(`${path}/index`);\n\t\t\t} else {\n\t\t\t\tmain = _resolveFilename(`${path}/index`);\n\t\t\t}\n\n\t\t\treturn main;\n\t\t}\n\n\t\t// load as directory\n\n\t\tfor (let i = 0; i < vm.options.sourceExtensions.length; i++) {\n\t\t\tconst ext = vm.options.sourceExtensions[i];\n\t\t\tif (fs.existsSync(`${path}/index.${ext}`)) return `${path}/index.${ext}`;\n\t\t}\n\n\t\tif (fs.existsSync(`${path}/index.json`)) return `${path}/index.json`;\n\t\tif (fs.existsSync(`${path}/index.node`)) return `${path}/index.node`;\n\n\t\treturn null;\n\t};\n\n\t/**\n\t * Builtin require.\n\t */\n\n\tconst _requireBuiltin = (moduleName) => {\n\t\tif (moduleName === 'buffer') return ({Buffer});\n\t\tif (BUILTINS[moduleName]) return BUILTINS[moduleName].exports; // Only compiled builtins are stored here\n\n\t\tif (moduleName === 'util') {\n\t\t\treturn Contextify.readonly(host.require(moduleName), {\n\t\t\t\t// Allows VM context to use util.inherits\n\t\t\t\tinherits: (ctor, superCtor) => {\n\t\t\t\t\tctor.super_ = superCtor;\n\t\t\t\t\tObject.setPrototypeOf(ctor.prototype, superCtor.prototype);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (moduleName === 'events' || moduleName === 'internal/errors') {\n\t\t\ttry {\n\t\t\t\tconst script = new Script(`(function (exports, require, module, process, internalBinding) {\n\t\t\t\t\t\t'use strict';\n\t\t\t\t\t\tconst primordials = global;\n\t\t\t\t\t\t${BUILTIN_MODULES[moduleName]}\n\t\t\t\t\t\t\\n\n\t\t\t\t\t});`, {\n\t\t\t\t\tfilename: `${moduleName}.vm.js`\n\t\t\t\t});\n\n\t\t\t\t// setup module scope\n\t\t\t\tconst module = BUILTINS[moduleName] = {\n\t\t\t\t\texports: {},\n\t\t\t\t\trequire: _requireBuiltin\n\t\t\t\t};\n\n\t\t\t\t// run script\n\t\t\t\tscript.runInContext(global)(module.exports, module.require, module, host.process, host.process.binding);\n\n\t\t\t\treturn module.exports;\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\n\t\treturn Contextify.readonly(host.require(moduleName));\n\t};\n\n\t/**\n\t * Prepare require.\n\t */\n\n\tconst _prepareRequire = (currentDirname, parentAllowsTransitive = false) => {\n\t\tconst _require = moduleName => {\n\t\t\tif (vm.options.nesting && moduleName === 'vm2') return {VM: Contextify.readonly(host.VM), NodeVM: Contextify.readonly(host.NodeVM)};\n\t\t\tif (!vm.options.require) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\tif (moduleName == null) throw new VMError(\"Module '' not found.\", 'ENOTFOUND');\n\t\t\tif (typeof moduleName !== 'string') throw new VMError(`Invalid module name '${moduleName}'`, 'EINVALIDNAME');\n\n\t\t\tlet filename;\n\t\t\tlet allowRequireTransitive = false;\n\n\t\t\t// Mock?\n\n\t\t\tif (vm.options.require.mock && vm.options.require.mock[moduleName]) {\n\t\t\t\treturn Contextify.readonly(vm.options.require.mock[moduleName]);\n\t\t\t}\n\n\t\t\t// Builtin?\n\n\t\t\tif (BUILTIN_MODULES[moduleName]) {\n\t\t\t\tif (host.Array.isArray(vm.options.require.builtin)) {\n\t\t\t\t\tif (vm.options.require.builtin.indexOf('*') >= 0) {\n\t\t\t\t\t\tif (vm.options.require.builtin.indexOf(`-${moduleName}`) >= 0) {\n\t\t\t\t\t\t\tthrow new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (vm.options.require.builtin.indexOf(moduleName) === -1) {\n\t\t\t\t\t\tthrow new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\t\t\t}\n\t\t\t\t} else if (vm.options.require.builtin) {\n\t\t\t\t\tif (!vm.options.require.builtin[moduleName]) {\n\t\t\t\t\t\tthrow new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\t\t\t\t}\n\n\t\t\t\treturn _requireBuiltin(moduleName);\n\t\t\t}\n\n\t\t\t// External?\n\n\t\t\tif (!vm.options.require.external) throw new VMError(`Access denied to require '${moduleName}'`, 'EDENIED');\n\n\t\t\tif (/^(\\.|\\.\\/|\\.\\.\\/)/.exec(moduleName)) {\n\t\t\t\t// Module is relative file, e.g. ./script.js or ../script.js\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tfilename = _resolveFilename(`${currentDirname}/${moduleName}`);\n\t\t\t} else if (/^(\\/|\\\\|[a-zA-Z]:\\\\)/.exec(moduleName)) {\n\t\t\t\t// Module is absolute file, e.g. /script.js or //server/script.js or C:\\script.js\n\n\t\t\t\tfilename = _resolveFilename(moduleName);\n\t\t\t} else {\n\t\t\t\t// Check node_modules in path\n\n\t\t\t\tif (!currentDirname) throw new VMError('You must specify script path to load relative modules.', 'ENOPATH');\n\n\t\t\t\tif (typeof vm.options.require.external === 'object') {\n\t\t\t\t\tconst { external, transitive } = _parseExternalOptions(vm.options.require.external);\n\n\t\t\t\t\tconst isWhitelisted = external.some(ext => host.helpers.match(ext, moduleName)) || (transitive && parentAllowsTransitive);\n\t\t\t\t\tif (!isWhitelisted) {\n\t\t\t\t\t\tthrow new VMError(`The module '${moduleName}' is not whitelisted in VM.`, 'EDENIED');\n\t\t\t\t\t}\n\n\t\t\t\t\tallowRequireTransitive = true;\n\t\t\t\t}\n\n\t\t\t\tconst paths = currentDirname.split(pa.sep);\n\n\t\t\t\twhile (paths.length) {\n\t\t\t\t\tconst path = paths.join(pa.sep);\n\n\t\t\t\t\t// console.log moduleName, \"#{path}#{pa.sep}node_modules#{pa.sep}#{moduleName}\"\n\n\t\t\t\t\tfilename = _resolveFilename(`${path}${pa.sep}node_modules${pa.sep}${moduleName}`);\n\t\t\t\t\tif (filename) break;\n\n\t\t\t\t\tpaths.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!filename && vm.options.require.resolve) {\n\t\t\t\tfilename = _resolveFilename(vm.options.require.resolve(moduleName, currentDirname));\n\t\t\t}\n\t\t\tif (!filename) throw new VMError(`Cannot find module '${moduleName}'`, 'ENOTFOUND');\n\n\t\t\t// return cache whenever possible\n\t\t\tif (CACHE[filename]) return CACHE[filename].exports;\n\n\t\t\tconst dirname = pa.dirname(filename);\n\t\t\tconst extname = pa.extname(filename);\n\n\t\t\tif (vm.options.require.root) {\n\t\t\t\tconst rootPaths = Array.isArray(vm.options.require.root) ? vm.options.require.root : [vm.options.require.root];\n\t\t\t\tconst allowedModule = rootPaths.some(path => dirname.startsWith(pa.resolve(path)));\n\n\t\t\t\tif (!allowedModule) {\n\t\t\t\t\tthrow new VMError(`Module '${moduleName}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst module = CACHE[filename] = {\n\t\t\t\tfilename,\n\t\t\t\texports: {},\n\t\t\t\trequire: _prepareRequire(dirname, allowRequireTransitive)\n\t\t\t};\n\n\t\t\t// lookup extensions\n\t\t\tif (EXTENSIONS[extname]) {\n\t\t\t\tEXTENSIONS[extname](module, filename, dirname);\n\t\t\t\treturn module.exports;\n\t\t\t}\n\n\t\t\tthrow new VMError(`Failed to load '${moduleName}': Unknown type.`, 'ELOADFAIL');\n\t\t};\n\n\t\treturn _require;\n\t};\n\n\t/**\n\t * Prepare sandbox.\n\t */\n\n\tglobal.setTimeout = (callback, delay, ...args) => {\n\t\tconst tmr = host.setTimeout(Decontextify.value(() => {\n\t\t\tcallback(...args);\n\t\t}), Decontextify.value(delay));\n\n\t\tconst local = {\n\t\t\tref: () => tmr.ref(),\n\t\t\tunref: () => tmr.unref()\n\t\t};\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setInterval = (callback, interval, ...args) => {\n\t\tconst tmr = host.setInterval(Decontextify.value(() => {\n\t\t\tcallback(...args);\n\t\t}), Decontextify.value(interval));\n\n\t\tconst local = {\n\t\t\tref: () => tmr.ref(),\n\t\t\tunref: () => tmr.unref()\n\t\t};\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.setImmediate = (callback, ...args) => {\n\t\tconst tmr = host.setImmediate(Decontextify.value(() => {\n\t\t\tcallback(...args);\n\t\t}));\n\n\t\tconst local = {\n\t\t\tref: () => tmr.ref(),\n\t\t\tunref: () => tmr.unref()\n\t\t};\n\n\t\tTIMERS.set(local, tmr);\n\t\treturn local;\n\t};\n\n\tglobal.clearTimeout = (local) => {\n\t\thost.clearTimeout(TIMERS.get(local));\n\t\treturn null;\n\t};\n\n\tglobal.clearInterval = (local) => {\n\t\thost.clearInterval(TIMERS.get(local));\n\t\treturn null;\n\t};\n\n\tglobal.clearImmediate = (local) => {\n\t\thost.clearImmediate(TIMERS.get(local));\n\t\treturn null;\n\t};\n\n\tglobal.process = {\n\t\targv: [],\n\t\ttitle: host.process.title,\n\t\tversion: host.process.version,\n\t\tversions: Contextify.readonly(host.process.versions),\n\t\tarch: host.process.arch,\n\t\tplatform: host.process.platform,\n\t\tenv: {},\n\t\tpid: host.process.pid,\n\t\tfeatures: Contextify.readonly(host.process.features),\n\t\tnextTick(callback, ...args) {\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tthrow new Error('Callback must be a function.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn host.process.nextTick(Decontextify.value(() => {\n\t\t\t\t\tcallback(...args);\n\t\t\t\t}));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\thrtime() {\n\t\t\ttry {\n\t\t\t\treturn host.process.hrtime();\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\tcwd() {\n\t\t\ttry {\n\t\t\t\treturn host.process.cwd();\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t},\n\t\ton(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.on(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tonce(name, handler) {\n\t\t\tif (name !== 'beforeExit' && name !== 'exit') {\n\t\t\t\tthrow new Error(`Access denied to listen for '${name}' event.`);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\thost.process.once(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tlisteners(name) {\n\t\t\t// Filter out listeners, which were not created in this sandbox (isVMProxy is undefined)\n\t\t\treturn Contextify.value(host.process.listeners(name).filter(listener => !Contextify.value(listener).isVMProxy));\n\t\t},\n\n\t\tremoveListener(name, handler) {\n\t\t\ttry {\n\t\t\t\thost.process.removeListener(name, Decontextify.value(handler));\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tumask() {\n\t\t\tif (arguments.length) {\n\t\t\t\tthrow new Error('Access denied to set umask.');\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\treturn host.process.umask();\n\t\t\t} catch (e) {\n\t\t\t\tthrow Contextify.value(e);\n\t\t\t}\n\t\t}\n\t};\n\n\tif (vm.options.console === 'inherit') {\n\t\tglobal.console = Contextify.readonly(host.console);\n\t} else if (vm.options.console === 'redirect') {\n\t\tglobal.console = {\n\t\t\tdebug(...args) {\n\t\t\t\tvm.emit('console.debug', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tlog(...args) {\n\t\t\t\tvm.emit('console.log', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tinfo(...args) {\n\t\t\t\tvm.emit('console.info', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\twarn(...args) {\n\t\t\t\tvm.emit('console.warn', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\terror(...args) {\n\t\t\t\tvm.emit('console.error', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tdir(...args) {\n\t\t\t\tvm.emit('console.dir', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\ttime: () => {},\n\t\t\ttimeEnd: () => {},\n\t\t\ttrace(...args) {\n\t\t\t\tvm.emit('console.trace', ...Decontextify.arguments(args));\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\t/*\n\tReturn contextized require.\n\t*/\n\n\treturn _prepareRequire;\n})(vm, host);\n";

/**
 * Cache where we can cache some things
 * 
 * @private
 * @property {?compileCallback} coffeeScriptCompiler - The coffee script compiler or null if not yet used.
 * @property {?Object} timeoutContext - The context used for the timeout functionality of null if not yet used.
 * @property {?vm.Script} timeoutScript - The compiled script used for the timeout functionality of null if not yet used.
 * @property {vm.Script} contextifyScript - The compiled script used to setup a sandbox.
 * @property {?vm.Script} sandboxScript - The compiled script used to setup the NodeVM require mechanism of null if not yet used.
 */
const CACHE = {
	coffeeScriptCompiler: null,
	timeoutContext: null,
	timeoutScript: null,
	contextifyScript: compileScript('contextify.js', contextifyJS, '(function(require, host) { ', '\n})'),
	sandboxScript: null,
	fixAsyncScript: null,
	getGlobalScript: null,
	getGeneratorFunctionScript: null,
	getAsyncFunctionScript: null,
	getAsyncGeneratorFunctionScript: null,
};

/**
 * Default run options for vm.Script.runInContext
 * 
 * @private
 */
const DEFAULT_RUN_OPTIONS = {displayErrors: false};

/**
 * Returns the cached coffee script compiler or loads it
 * if it is not found in the cache.
 * 
 * @private
 * @return {compileCallback} The coffee script compiler.
 * @throws {VMError} If the coffee-script module can't be found.
 */
function getCoffeeScriptCompiler() {
	if (!CACHE.coffeeScriptCompiler) {
		try {
			const coffeeScript = require('coffee-script');
			CACHE.coffeeScriptCompiler = (code, filename) => {
				return coffeeScript.compile(code, {header: false, bare: true});
			};
		} catch (e) {
			throw new VMError('Coffee-Script compiler is not installed.');
		}
	}
	return CACHE.coffeeScriptCompiler;
}

/**
 * The JavaScript compiler, just a identity function.
 * 
 * @private
 * @type {compileCallback}
 * @param {string} code - The JavaScript code.
 * @param {string} filename - Filename of this script.
 * @return {string} The code.
 */
function jsCompiler(code, filename) {
	return code;
}

/**
 * Look up the compiler for a specific name.
 * 
 * @private
 * @param {(string|compileCallback)} compiler - A compile callback or the name of the compiler.
 * @return {compileCallback} The resolved compiler.
 * @throws {VMError} If the compiler is unknown or the coffee script module was needed and couldn't be found.
 */
function lookupCompiler(compiler) {
	if ('function' === typeof compiler) return compiler;
	switch (compiler) {
		case 'coffeescript':
		case 'coffee-script':
		case 'cs':
		case 'text/coffeescript':
			return getCoffeeScriptCompiler();
		case 'javascript':
		case 'java-script':
		case 'js':
		case 'text/javascript':
			return jsCompiler;
		default:
			throw new VMError(`Unsupported compiler '${compiler}'.`);
	}
}

/**
 * Class Script
 *
 * @public
 */
class VMScript {

	/**
	 * The script code with wrapping. If set will invalidate the cache.<br>
	 * Writable only for backwards compatibility.
	 * 
	 * @public
	 * @readonly
	 * @member {string} code
	 * @memberOf VMScript#
	 */

	/**
	 * The filename used for this script.
	 * 
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {string} filename
	 * @memberOf VMScript#
	 */

	/**
	 * The line offset use for stack traces.
	 * 
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {number} lineOffset
	 * @memberOf VMScript#
	 */

	/**
	 * The column offset use for stack traces.
	 * 
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {number} columnOffset
	 * @memberOf VMScript#
	 */

	/**
	 * The compiler to use to get the JavaScript code.
	 * 
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {(string|compileCallback)} compiler
	 * @memberOf VMScript#
	 */

	/**
	 * The prefix for the script.
	 * 
	 * @private
	 * @member {string} _prefix
	 * @memberOf VMScript#
	 */

	/**
	 * The suffix for the script.
	 * 
	 * @private
	 * @member {string} _suffix
	 * @memberOf VMScript#
	 */

	/**
	 * The compiled vm.Script for the VM or if not compiled <code>null</code>.
	 * 
	 * @private
	 * @member {?vm.Script} _compiledVM
	 * @memberOf VMScript#
	 */

	/**
	 * The compiled vm.Script for the NodeVM or if not compiled <code>null</code>.
	 * 
	 * @private
	 * @member {?vm.Script} _compiledNodeVM
	 * @memberOf VMScript#
	 */

	/**
	 * The resolved compiler to use to get the JavaScript code.
	 * 
	 * @private
	 * @readonly
	 * @member {compileCallback} _compiler
	 * @memberOf VMScript#
	 */

	/**
	 * The script to run without wrapping.
	 * 
	 * @private
	 * @member {string} _code
	 * @memberOf VMScript#
	 */

	/**
	 * Create VMScript instance.
	 *
	 * @public
	 * @param {string} code - Code to run.
	 * @param {(string|Object)} [options] - Options map or filename.
	 * @param {string} [options.filename="vm.js"] - Filename that shows up in any stack traces produced from this script.
	 * @param {number} [options.lineOffset=0] - Passed to vm.Script options.
	 * @param {number} [options.columnOffset=0] - Passed to vm.Script options.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @throws {VMError} If the compiler is unknown or if coffee-script was requested but the module not found.
	 */
	constructor(code, options) {
		const sCode = `${code}`;
		let useFileName;
		let useOptions;
		if (arguments.length === 2) {
			if (typeof options === 'object' && options.toString === Object.prototype.toString) {
				useOptions = options || {};
				useFileName = useOptions.filename;
			} else {
				useOptions = {};
				useFileName = options;
			}
		} else if (arguments.length > 2) {
			// We do it this way so that there are no more arguments in the function.
			// eslint-disable-next-line prefer-rest-params
			useOptions = arguments[2] || {};
			useFileName = options || useOptions.filename;
		} else {
			useOptions = {};
		}

		const {
			compiler = 'javascript',
			lineOffset = 0,
			columnOffset = 0
		} = useOptions;

		// Throw if the compiler is unknown.
		const resolvedCompiler = lookupCompiler(compiler);

		Object.defineProperties(this, {
			code: {
				// Put this here so that it is enumerable, and looks like a property.
				get() {
					return this._prefix + this._code + this._suffix;
				},
				set(value) {
					const strNewCode = String(value);
					if (strNewCode === this._code && this._prefix === '' && this._suffix === '') return;
					this._code = strNewCode;
					this._prefix = '';
					this._suffix = '';
					this._compiledVM = null;
					this._compiledNodeVM = null;
				},
				enumerable: true
			},
			filename: {
				value: useFileName || 'vm.js',
				enumerable: true
			},
			lineOffset: {
				value: lineOffset,
				enumerable: true
			},
			columnOffset: {
				value: columnOffset,
				enumerable: true
			},
			compiler: {
				value: compiler,
				enumerable: true
			},
			_code: {
				value: sCode,
				writable: true
			},
			_prefix: {
				value: '',
				writable: true
			},
			_suffix: {
				value: '',
				writable: true
			},
			_compiledVM: {
				value: null,
				writable: true
			},
			_compiledNodeVM: {
				value: null,
				writable: true
			},
			_compiler: {value: resolvedCompiler}
		});
	}

	/**
	 * Wraps the code.<br>
	 * This will replace the old wrapping.<br>
	 * Will invalidate the code cache.
	 *
	 * @public
	 * @deprecated Since v3.8.5. Wrap your code before passing it into the VMScript object.
	 * @param {string} prefix - String that will be appended before the script code.
	 * @param {script} suffix - String that will be appended behind the script code.
	 * @return {this} This for chaining.
	 * @throws {TypeError} If prefix or suffix is a Symbol.
	 */
	wrap(prefix, suffix) {
		const strPrefix = `${prefix}`;
		const strSuffix = `${suffix}`;
		if (this._prefix === strPrefix && this._suffix === strSuffix) return this;
		this._prefix = strPrefix;
		this._suffix = strSuffix;
		this._compiledVM = null;
		this._compiledNodeVM = null;
		return this;
	}

	/**
	 * Compile this script. <br>
	 * This is useful to detect syntax errors in the script.
	 *
	 * @public
	 * @return {this} This for chaining.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */
	compile() {
		this._compileVM();
		return this;
	}

	/**
	 * Compiles this script to a vm.Script.
	 * 
	 * @private
	 * @param {string} prefix - JavaScript code that will be used as prefix.
	 * @param {string} suffix - JavaScript code that will be used as suffix.
	 * @return {vm.Script} The compiled vm.Script.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */
	_compile(prefix, suffix) {
		return new vm.Script(prefix + this._compiler(this._prefix + this._code + this._suffix, this.filename) + suffix, {
			filename: this.filename,
			displayErrors: false,
			lineOffset: this.lineOffset,
			columnOffset: this.columnOffset
		});
	}

	/**
	 * Will return the cached version of the script intended for VM or compile it.
	 * 
	 * @private
	 * @return {vm.Script} The compiled script
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */
	_compileVM() {
		let script = this._compiledVM;
		if (!script) {
			this._compiledVM = script = this._compile('', '');
		}
		return script;
	}

	/**
	 * Will return the cached version of the script intended for NodeVM or compile it.
	 * 
	 * @private
	 * @return {vm.Script} The compiled script
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */
	_compileNodeVM() {
		let script = this._compiledNodeVM;
		if (!script) {
			this._compiledNodeVM = script = this._compile('(function (exports, require, module, __filename, __dirname) { ', '\n})');
		}
		return script;
	}

}

/**
 * 
 * This callback will be called and has a specific time to finish.<br>
 * No parameters will be supplied.<br>
 * If parameters are required, use a closure.
 * 
 * @private
 * @callback runWithTimeout
 * @return {*} 
 * 
 */

/**
 * Run a function with a specific timeout.
 * 
 * @private
 * @param {runWithTimeout} fn - Function to run with the specific timeout.
 * @param {number} timeout - The amount of time to give the function to finish.
 * @return {*} The value returned by the function.
 * @throws {Error} If the function took to long.
 */
function doWithTimeout(fn, timeout) {
	let ctx = CACHE.timeoutContext;
	let script = CACHE.timeoutScript;
	if (!ctx) {
		CACHE.timeoutContext = ctx = vm.createContext();
		CACHE.timeoutScript = script = new vm.Script('fn()', {
			filename: 'timeout_bridge.js',
			displayErrors: false
		});
	}
	ctx.fn = fn;
	try {
		return script.runInContext(ctx, {
			displayErrors: false,
			timeout
		});
	} finally {
		ctx.fn = null;
	}
}

/**
 * Class VM.
 *
 * @public
 */
class VM extends EventEmitter {

	/**
	 * The timeout for {@link VM#run} calls.
	 *
	 * @public
	 * @since v3.8.5
	 * @member {number} timeout
	 * @memberOf VM#
	 */

	/**
	 * Get the global sandbox object.
	 *
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {Object} sandbox
	 * @memberOf VM#
	 */

	/**
	 * The compiler to use to get the JavaScript code.
	 * 
	 * @public
	 * @readonly
	 * @since v3.8.5
	 * @member {(string|compileCallback)} compiler
	 * @memberOf VM#
	 */

	/**
	 * The context for this sandbox.
	 * 
	 * @private
	 * @readonly
	 * @member {Object} _context
	 * @memberOf VM#
	 */

	/**
	 * The internal methods for this sandbox.
	 * 
	 * @private
	 * @readonly
	 * @member {{Contextify: Object, Decontextify: Object, Buffer: Object, sandbox:Object}} _internal
	 * @memberOf VM#
	 */

	/**
	 * The resolved compiler to use to get the JavaScript code.
	 * 
	 * @private
	 * @readonly
	 * @member {compileCallback} _compiler
	 * @memberOf VM#
	 */

	/**
	 * Create a new VM instance.
	 *
	 * @public
	 * @param {Object} [options] - VM options.
	 * @param {number} [options.timeout] - The amount of time until a call to {@link VM#run} will timeout.
	 * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.fixAsync=false] - Filters for async functions.
	 * @throws {VMError} If the compiler is unknown.
	 */
	constructor(options = {}) {
		super();

		// Read all options
		const {
			timeout,
			sandbox,
			compiler = 'javascript'
		} = options;
		const allowEval = options.eval !== false;
		const allowWasm = options.wasm !== false;
		const fixAsync = !!options.fixAsync;

		// Early error if sandbox is not an object.
		if (sandbox && 'object' !== typeof sandbox) {
			throw new VMError('Sandbox must be object.');
		}

		// Early error if compiler can't be found.
		const resolvedCompiler = lookupCompiler(compiler);

		// Create a new context for this vm.
		const _context = vm.createContext(undefined, {
			codeGeneration: {
				strings: allowEval,
				wasm: allowWasm
			}
		});

		// Create the bridge between the host and the sandbox.
		const _internal = CACHE.contextifyScript.runInContext(_context, DEFAULT_RUN_OPTIONS).call(_context, require, HOST);

		// Define the properties of this object.
		// Use Object.defineProperties here to be able to
		// hide and set properties write only.
		Object.defineProperties(this, {
			timeout: {
				value: timeout,
				writable: true,
				enumerable: true
			},
			compiler: {
				value: compiler,
				enumerable: true
			},
			sandbox: {
				value: _internal.sandbox,
				enumerable: true
			},
			_context: {value: _context},
			_internal: {value: _internal},
			_compiler: {value: resolvedCompiler},
			_fixAsync: {value: fixAsync}
		});

		if (fixAsync) {
			if (!CACHE.fixAsyncScript) {
				CACHE.fixAsyncScript = compileScript('fixasync.js', fixAsyncJS, '(function() { ', '\n})');
				CACHE.getGlobalScript = new vm.Script('this', {
					filename: 'get_global.js',
					displayErrors: false
				});
				try {
					CACHE.getGeneratorFunctionScript = new vm.Script('(function*(){}).constructor', {
						filename: 'get_generator_function.js',
						displayErrors: false
					});
				} catch (ex) {}
				try {
					CACHE.getAsyncFunctionScript = new vm.Script('(async function(){}).constructor', {
						filename: 'get_async_function.js',
						displayErrors: false
					});
				} catch (ex) {}
				try {
					CACHE.getAsyncGeneratorFunctionScript = new vm.Script('(async function*(){}).constructor', {
						filename: 'get_async_generator_function.js',
						displayErrors: false
					});
				} catch (ex) {}
			}
			const internal = {
				__proto__: null,
				global: CACHE.getGlobalScript.runInContext(this._context, DEFAULT_RUN_OPTIONS),
				Contextify: this._internal.Contextify,
				host: HOST
			};
			if (CACHE.getGeneratorFunctionScript) {
				try {
					internal.GeneratorFunction = CACHE.getGeneratorFunctionScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);
				} catch (ex) {}
			}
			if (CACHE.getAsyncFunctionScript) {
				try {
					internal.AsyncFunction = CACHE.getAsyncFunctionScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);
				} catch (ex) {}
			}
			if (CACHE.getAsyncGeneratorFunctionScript) {
				try {
					internal.AsyncGeneratorFunction = CACHE.getAsyncGeneratorFunctionScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);
				} catch (ex) {}
			}
			CACHE.fixAsyncScript.runInContext(this._context, DEFAULT_RUN_OPTIONS).call(internal);
		}

		// prepare global sandbox
		if (sandbox) {
			this.setGlobals(sandbox);
		}
	}

	/**
	 * Adds all the values to the globals.
	 * 
	 * @public
	 * @since v3.8.5
	 * @param {Object} values - All values that will be added to the globals.
	 * @return {this} This for chaining.
	 * @throws {*} If the setter of a global throws an exception it is propagated. And the remaining globals will not be written.
	 */
	setGlobals(values) {
		for (const name in values) {
			if (Object.prototype.hasOwnProperty.call(values, name)) {
				this._internal.Contextify.setGlobal(name, values[name]);
			}
		}
		return this;
	}

	/**
	 * Set a global value.
	 * 
	 * @public
	 * @since v3.8.5
	 * @param {string} name - The name of the global.
	 * @param {*} value - The value of the global.
	 * @return {this} This for chaining.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */
	setGlobal(name, value) {
		this._internal.Contextify.setGlobal(name, value);
		return this;
	}

	/**
	 * Get a global value.
	 * 
	 * @public
	 * @since v3.8.5
	 * @param {string} name - The name of the global.
	 * @return {*} The value of the global.
	 * @throws {*} If the getter of the global throws an exception it is propagated.
	 */
	getGlobal(name) {
		return this._internal.Contextify.getGlobal(name);
	}

	/**
	 * Freezes the object inside VM making it read-only. Not available for primitive values.
	 *
	 * @public
	 * @param {*} value - Object to freeze.
	 * @param {string} [globalName] - Whether to add the object to global.
	 * @return {*} Object to freeze.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */
	freeze(value, globalName) {
		this._internal.Contextify.readonly(value);
		if (globalName) this._internal.Contextify.setGlobal(globalName, value);
		return value;
	}

	/**
	 * Protects the object inside VM making impossible to set functions as it's properties. Not available for primitive values.
	 *
	 * @public
	 * @param {*} value - Object to protect.
	 * @param {string} [globalName] - Whether to add the object to global.
	 * @return {*} Object to protect.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */
	protect(value, globalName) {
		this._internal.Contextify.protected(value);
		if (globalName) this._internal.Contextify.setGlobal(globalName, value);
		return value;
	}

	/**
	 * Run the code in VM.
	 *
	 * @public
	 * @param {(string|VMScript)} code - Code to run.
	 * @param {string} [filename="vm.js"] - Filename that shows up in any stack traces produced from this script.<br>
	 * This is only used if code is a String.
	 * @return {*} Result of executed code.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {Error} An error is thrown when the script took to long and there is a timeout.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */
	run(code, filename) {
		let script;
		if (code instanceof VMScript) {
			if (this._fixAsync && /\basync\b/.test(code.code)) {
				throw new VMError('Async not available');
			}
			script = code._compileVM();
		} else {
			if (this._fixAsync && /\basync\b/.test(code)) {
				throw new VMError('Async not available');
			}
			const useFileName = filename || 'vm.js';
			// Compile the script here so that we don't need to create a instance of VMScript.
			script = new vm.Script(this._compiler(code, useFileName), {
				filename: useFileName,
				displayErrors: false
			});
		}

		if (!this.timeout) {
			// If no timeout is given, directly run the script.
			try {
				return this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));
			} catch (e) {
				throw this._internal.Decontextify.value(e);
			}
		}

		return doWithTimeout(()=>{
			try {
				return this._internal.Decontextify.value(script.runInContext(this._context, DEFAULT_RUN_OPTIONS));
			} catch (e) {
				throw this._internal.Decontextify.value(e);
			}
		}, this.timeout);
	}

	/**
	 * Run the code in VM.
	 *
	 * @public
	 * @since v3.8.5
	 * @param {string} filename - Filename of file to load and execute in a NodeVM.
	 * @return {*} Result of executed code.
	 * @throws {Error} If filename is not a valid filename.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {Error} An error is thrown when the script took to long and there is a timeout.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */
	runFile(filename) {
		const resolvedFilename = pa.resolve(filename);

		if (!fs.existsSync(resolvedFilename)) {
			throw new VMError(`Script '${filename}' not found.`);
		}

		if (fs.statSync(resolvedFilename).isDirectory()) {
			throw new VMError('Script must be file, got directory.');
		}

		return this.run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);
	}

}

/**
 * Event caused by a <code>console.debug</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.debug"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.log</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.log"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.info</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.info"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.warn</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.warn"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.error</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.error"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.dir</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.dir"
 * @type {...*}
 */

/**
 * Event caused by a <code>console.trace</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.trace"
 * @type {...*}
 */

/**
 * Class NodeVM.
 *
 * @public
 * @extends {VM}
 * @extends {EventEmitter}
 */
class NodeVM extends VM {

	/**
	 * Create a new NodeVM instance.<br>
	 *
	 * Unlike VM, NodeVM lets you use require same way like in regular node.<br>
	 * 
	 * However, it does not use the timeout.
	 *
	 * @public
	 * @param {Object} [options] - VM options.
	 * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>
	 * Only available for node v10+.
	 * @param {("inherit"|"redirect"|"off")} [options.console="inherit"] - Sets the behavior of the console in the sandbox.
	 * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.
	 * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.
	 * @param {(boolean|string[]|Object)} [options.require.external=false] - true, an array of allowed external modules or an object.
	 * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??], 
	 * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.
	 * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.
	 * @param {string[]} [options.require.builtin=[]] - Array of allowed builtin modules, accepts ["*"] for all.
	 * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.
	 * @param {Object} [options.require.mock] - Collection of mock modules (both external or builtin).
	 * @param {("host"|"sandbox")} [options.require.context="host"] - <code>host</code> to require modules in host and proxy them to sandbox.
	 * <code>sandbox</code> to load, compile and require modules in sandbox.
	 * Builtin modules except <code>events</code> always required in host and proxied to sandbox.
	 * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.
	 * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't
	 * found in one of the traditional node lookup paths.
	 * @param {boolean} [options.nesting=false] - Allow nesting of VMs.
	 * @param {("commonjs"|"none")} [options.wrapper="commonjs"] - <code>commonjs</code> to wrap script into CommonJS wrapper, 
	 * <code>none</code> to retrieve value returned by the script.
	 * @param {string[]} [options.sourceExtensions=["js"]] - Array of file extensions to treat as source code.
	 * @throws {VMError} If the compiler is unknown.
	 */
	constructor(options = {}) {
		const sandbox = options.sandbox;

		// Throw this early
		if (sandbox && 'object' !== typeof sandbox) {
			throw new VMError('Sandbox must be object.');
		}

		super({compiler: options.compiler, eval: options.eval, wasm: options.wasm});

		// defaults
		Object.defineProperty(this, 'options', {value: {
			console: options.console || 'inherit',
			require: options.require || false,
			nesting: options.nesting || false,
			wrapper: options.wrapper || 'commonjs',
			sourceExtensions: options.sourceExtensions || ['js']
		}});

		let sandboxScript = CACHE.sandboxScript;
		if (!sandboxScript) {
			CACHE.sandboxScript = sandboxScript = compileScript('sandboxy.js', sandboxJS,
				'(function (vm, host, Contextify, Decontextify, Buffer) { ', '\n})');
		}

		const closure = sandboxScript.runInContext(this._context, DEFAULT_RUN_OPTIONS);

		Object.defineProperty(this, '_prepareRequire', {
			value: closure.call(this._context, this, HOST, this._internal.Contextify, this._internal.Decontextify, this._internal.Buffer)
		});

		// prepare global sandbox
		if (sandbox) {
			this.setGlobals(sandbox);
		}

		if (this.options.require && this.options.require.import) {
			if (Array.isArray(this.options.require.import)) {
				for (let i = 0, l = this.options.require.import.length; i < l; i++) {
					this.require(this.options.require.import[i]);
				}
			} else {
				this.require(this.options.require.import);
			}
		}
	}

	/**
	 * @ignore
	 * @deprecated Just call the method yourself like <code>method(args);</code>
	 * @param {function} method - Function to invoke.
	 * @param {...*} args - Arguments to pass to the function.
	 * @return {*} Return value of the function.
	 * @todo Can we remove this function? It even had a bug that would use args as this parameter.
	 * @throws {*} Rethrows anything the method throws.
	 * @throws {VMError} If method is not a function.
	 * @throws {Error} If method is a class.
	 */
	call(method, ...args) {
		if ('function' === typeof method) {
			return method(...args);
		} else {
			throw new VMError('Unrecognized method type.');
		}
	}

	/**
	 * Require a module in VM and return it's exports.
	 *
	 * @public
	 * @param {string} module - Module name.
	 * @return {*} Exported module.
	 * @throws {*} If the module couldn't be found or loading it threw an error.
	 */
	require(module) {
		return this.run(`module.exports = require('${module}');`, 'vm.js');
	}

	/**
	 * Run the code in NodeVM.
	 *
	 * First time you run this method, code is executed same way like in node's regular `require` - it's executed with
	 * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.
	 *
	 * @param {(string|VMScript)} code - Code to run.
	 * @param {string} [filename] - Filename that shows up in any stack traces produced from this script.<br>
	 * This is only used if code is a String.
	 * @return {*} Result of executed code.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 * @fires NodeVM."console.debug"
	 * @fires NodeVM."console.log"
	 * @fires NodeVM."console.info"
	 * @fires NodeVM."console.warn"
	 * @fires NodeVM."console.error"
	 * @fires NodeVM."console.dir"
	 * @fires NodeVM."console.trace"
	 */
	run(code, filename) {
		let dirname;
		let resolvedFilename;
		let script;

		if (code instanceof VMScript) {
			script = code._compileNodeVM();
			resolvedFilename = pa.resolve(code.filename);
			dirname = pa.dirname(resolvedFilename);
		} else {
			const unresolvedFilename = filename || 'vm.js';
			if (filename) {
				resolvedFilename = pa.resolve(filename);
				dirname = pa.dirname(resolvedFilename);
			} else {
				resolvedFilename = null;
				dirname = null;
			}
			script = new vm.Script('(function (exports, require, module, __filename, __dirname) { ' +
					this._compiler(code, unresolvedFilename) + '\n})', {
				filename: unresolvedFilename,
				displayErrors: false
			});
		}

		const wrapper = this.options.wrapper;
		const module = this._internal.Contextify.makeModule();

		try {
			const closure = script.runInContext(this._context, DEFAULT_RUN_OPTIONS);

			const returned = closure.call(this._context, module.exports, this._prepareRequire(dirname), module, resolvedFilename, dirname);

			return this._internal.Decontextify.value(wrapper === 'commonjs' ? module.exports : returned);
		} catch (e) {
			throw this._internal.Decontextify.value(e);
		}

	}

	/**
	 * Create NodeVM and run code inside it.
	 *
	 * @public
	 * @static
	 * @param {string} script - Code to execute.
	 * @param {string} [filename] - File name (used in stack traces only).
	 * @param {Object} [options] - VM options.
	 * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.
	 * @return {*} Result of executed code.
	 * @see {@link NodeVM} for the options.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */
	static code(script, filename, options) {
		let unresolvedFilename;
		if (filename != null) {
			if ('object' === typeof filename) {
				options = filename;
				unresolvedFilename = options.filename;
			} else if ('string' === typeof filename) {
				unresolvedFilename = filename;
			} else {
				throw new VMError('Invalid arguments.');
			}
		} else if ('object' === typeof options) {
			unresolvedFilename = options.filename;
		}

		if (arguments.length > 3) {
			throw new VMError('Invalid number of arguments.');
		}

		const resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;

		return new NodeVM(options).run(script, resolvedFilename);
	}

	/**
	 * Create NodeVM and run script from file inside it.
	 *
	 * @public
	 * @static
	 * @param {string} filename - Filename of file to load and execute in a NodeVM.
	 * @param {Object} [options] - NodeVM options.
	 * @return {*} Result of executed code.
	 * @see {@link NodeVM} for the options.
	 * @throws {Error} If filename is not a valid filename.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */
	static file(filename, options) {
		const resolvedFilename = pa.resolve(filename);

		if (!fs.existsSync(resolvedFilename)) {
			throw new VMError(`Script '${filename}' not found.`);
		}

		if (fs.statSync(resolvedFilename).isDirectory()) {
			throw new VMError('Script must be file, got directory.');
		}

		return new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);
	}
}

/**
 * VMError.
 *
 * @public
 * @extends {Error}
 */
class VMError extends Error {

	/**
	 * Create VMError instance.
	 *
	 * @public
	 * @param {string} message - Error message.
	 */
	constructor(message) {
		super(message);

		this.name = 'VMError';

		Error.captureStackTrace(this, this.constructor);
	}
}

/**
 * Host objects
 * 
 * @private
 */
const HOST = {
	version: parseInt(process.versions.node.split('.')[0]),
	require: eval('require'),
	process,
	console,
	setTimeout,
	setInterval,
	setImmediate,
	clearTimeout,
	clearInterval,
	clearImmediate,
	String,
	Number,
	Buffer,
	Boolean,
	Array,
	Date,
	Error,
	EvalError,
	RangeError,
	ReferenceError,
	SyntaxError,
	TypeError,
	URIError,
	RegExp,
	Function,
	Object,
	VMError,
	Proxy,
	Reflect,
	Map,
	WeakMap,
	Set,
	WeakSet,
	Promise,
	Symbol,
	INSPECT_MAX_BYTES,
	VM,
	NodeVM,
	helpers
};

exports.VMError = VMError;
exports.NodeVM = NodeVM;
exports.VM = VM;
exports.VMScript = VMScript;
