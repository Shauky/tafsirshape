"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatWarning = formatWarning;
exports.getMapResponse = getMapResponse;
exports.migrateListQueries = migrateListQueries;
exports.connectorWithMigrations = connectorWithMigrations;

var _language = require("graphql/language");

var _ast = require("./ast");

function wrapListQuerySelection(selectionSet) {
  return {
    kind: 'SelectionSet',
    selections: [{
      kind: 'Field',
      name: {
        kind: 'Name',
        value: 'items'
      },
      arguments: [],
      directives: [],
      selectionSet
    }, {
      kind: 'Field',
      name: {
        kind: 'Name',
        value: 'total'
      },
      arguments: [],
      directives: []
    }]
  };
}

function isOldListQuery(selection) {
  if (selection.kind !== 'Field') {
    return false;
  }

  const {
    name,
    selectionSet
  } = selection;
  return Boolean(name.value.match(/^get.+List$/) && selectionSet && !selectionSet.selections.find(selection => selection.kind === 'Field' && (selection.name.value === 'items' || selection.name.value === 'total')));
}

const startLocation = {
  line: 0,
  column: 0
};

function formatWarning(name, loc, queryStr, source) {
  const location = queryStr && loc && source ? (0, _language.getLocation)({
    body: queryStr,
    name: source,
    locationOffset: startLocation
  }, loc.start) : {
    line: 0,
    column: 0
  };
  return {
    message: `Using old format of ${name} Line ${location.line} Column ${location.column}`,
    location,
    source: source || ''
  };
}

function getMapResponse(props) {
  return res => {
    // shallow clone res
    const newRes = { ...res
    };
    newRes.data = { ...res.data
    };

    for (const prop of props) {
      if (res.data && res.data[prop]) {
        newRes.data[prop] = res.data[prop].items;
      }
    }

    return newRes;
  };
}

function migrateListQueries(ast, queryStr, source) {
  let migrated = false;
  const migratedProps = [];
  const warnings = [];
  const queryDef = ast.definitions.find(_ast.isQueryNode);

  if (queryDef) {
    for (const selection of queryDef.selectionSet.selections) {
      if (isOldListQuery(selection) && selection.selectionSet) {
        migratedProps.push(selection.alias ? selection.alias.value : selection.name.value);
        migrated = true;
        selection.selectionSet = wrapListQuerySelection(selection.selectionSet);
        warnings.push(formatWarning(selection.name.value, selection.loc, queryStr, source));
      }
    }
  }

  return {
    ast,
    warnings,
    migrated,
    mapResponse: migrated ? getMapResponse(migratedProps) : null
  };
}

function connectorWithMigrations(connector) {
  return async (gqlParams, {
    stats,
    source = 'query.graphql',
    applyMigrations = true
  } = {}) => {
    if (!applyMigrations) {
      return connector(gqlParams);
    }

    let {
      query
    } = gqlParams;
    const queryAst = (0, _ast.parse)(query);
    const {
      migrated,
      warnings,
      ast,
      mapResponse
    } = migrateListQueries(queryAst, query, source);

    if (migrated) {
      query = (0, _language.print)(ast);
    }

    if (warnings && stats && stats.warnings) {
      stats.warnings = stats.warnings.concat(warnings);
    }

    const res = await connector({
      query,
      variables: gqlParams.variables
    });
    return migrated && mapResponse ? mapResponse(res) : res;
  };
}