"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFieldUsage = getFieldUsage;
exports.detectTypes = detectTypes;
exports.getTypeUsage = getTypeUsage;

var _bluebird = _interopRequireDefault(require("bluebird"));

var _graphql = require("graphql");

var _ast = require("./ast");

var _query = require("./query");

var _config = require("../config");

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const startLocation = {
  line: 0,
  column: 0
};

function getFieldUsage(queryAst, schema, fileInfo) {
  const typeInfo = new _graphql.TypeInfo(schema);
  const result = {};
  const visitor = {
    Field: {
      enter(node) {
        const type = (0, _query.getItemType)(typeInfo.getFieldDef().type);
        const fields = (0, _query.getFields)(type);
        const fieldInfo = result[type.toString()] || {};

        if (fields && node.selectionSet) {
          node.selectionSet.selections.forEach(selection => {
            if (selection.kind === 'Field' || selection.kind === 'FragmentSpread') {
              const name = selection.name.value;
              const usage = fieldInfo[name] ? fieldInfo[name].usage : [];
              const source = {
                body: fileInfo.body,
                name: fileInfo.name,
                locationOffset: startLocation
              };
              fieldInfo[name] = {
                type: fields[name].type.toString(),
                usage: usage.concat({
                  file: fileInfo.name,
                  location: selection.loc ? (0, _graphql.getLocation)(source, selection.loc.start) : startLocation
                })
              };
            }
          });
          result[type.toString()] = fieldInfo;
        }
      }

    }
  };
  (0, _graphql.visit)(queryAst, (0, _graphql.visitWithTypeInfo)(typeInfo, visitor));
  return result;
}

function detectTypes(queryAst, schema) {
  const typeInfo = new _graphql.TypeInfo(schema);
  const result = new Set();
  const queryType = schema.getQueryType();

  if (!queryType) {
    throw new Error('Invalid schema has no queries');
  }

  const topLevelQueries = new Set(Object.keys(queryType.getFields()));
  const visitor = {
    Field: {
      enter(node) {
        if (topLevelQueries.has(node.name.value)) {
          const fieldType = typeInfo.getFieldDef().type;

          if ((0, _graphql.isObjectType)(fieldType)) {
            const fields = fieldType.getFields();

            if (fields.items && (0, _graphql.isListType)(fields.items.type)) {
              result.add(fields.items.type.ofType.toString());
            } else {
              result.add(fieldType.toString());
            }
          }
        }
      }

    }
  };
  (0, _graphql.visit)(queryAst, (0, _graphql.visitWithTypeInfo)(typeInfo, visitor));
  return result;
}

async function getTypeUsage({
  config,
  schema,
  fileLoader
}) {
  const queries = (0, _config.getGraphQLQueries)(config);
  return _bluebird.default.reduce(queries, async (result, routeQuery) => {
    const {
      filePath,
      ...info
    } = routeQuery;
    const queryString = await fileLoader(_path.default.join(config.templatePath, filePath));
    const types = detectTypes((0, _ast.parse)(queryString), schema);

    for (const type of types) {
      if (!result[type]) result[type] = [];
      result[type].push(info);
    }

    return result;
  }, {});
}