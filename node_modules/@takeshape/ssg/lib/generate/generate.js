"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculatePages = calculatePages;
exports.hasListPageConfig = hasListPageConfig;
exports.hasItemPageConfig = hasItemPageConfig;
exports.renderPaginatedTemplate = renderPaginatedTemplate;
exports.generateRoute = generateRoute;
exports.default = generate;

require("../async-iterator-polyfill");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _resolveContext = _interopRequireWildcard(require("../resolve-context"));

var _graphql = require("../graphql");

var _nunjucks = _interopRequireDefault(require("../nunjucks"));

var _compressHtml = _interopRequireDefault(require("../compress-html"));

var _paths = require("../paths");

var _graphqlError = _interopRequireDefault(require("../errors/graphql-error"));

var _paginationError = _interopRequireDefault(require("../errors/pagination-error"));

var _flatten = _interopRequireDefault(require("lodash/fp/flatten"));

var _partition = _interopRequireDefault(require("lodash/partition"));

var _values = _interopRequireDefault(require("lodash/values"));

var _streams = require("@takeshape/streams");

var _streams2 = require("./streams");

var _context = require("./context");

var _config = require("../config");

var _asyncIteratorToStream = _interopRequireDefault(require("async-iterator-to-stream"));

var _pumpify = require("pumpify");

var _compose = _interopRequireDefault(require("lodash/fp/compose"));

var _gzip = _interopRequireDefault(require("../gzip"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pageSize = Number(process.env.TS_EXPERIMENTAL_PAGE_SIZE) || 100;

const getPaginatedData = async (generateContext, paginate, context) => {
  const {
    connector,
    fileLoader,
    srcPath,
    clientSchema,
    stats
  } = generateContext;

  if (paginate.data) {
    const config = await (0, _resolveContext.resolveGraphQLConfig)(paginate.data, {
      fileLoader,
      srcPath
    });
    const res = await (0, _graphql.getQueryIterator)(clientSchema, config.query, connector, {
      pageSize,
      variables: config.variables,
      source: config.source,
      stats
    });
    return {
      iterable: res.iterator(),
      total: res.total
    };
  }

  if (paginate.property) {
    const itemsArray = context[paginate.property];

    if (itemsArray) {
      const filtered = itemsArray.filter(Boolean);
      return {
        iterable: filtered,
        total: filtered.length
      };
    }
  }

  return null;
};

function calculatePages(total, pageSize) {
  return Math.ceil(total / pageSize);
}

function hasListPageConfig(paginate) {
  return Boolean(paginate.pageSize && paginate.template && paginate.path);
}

function hasItemPageConfig(route) {
  return Boolean(route.path && route.template);
}

function renderPaginatedTemplate(generateContext, getPaginatedData) {
  const {
    renderTemplate,
    stats,
    pathPrefix
  } = generateContext;
  return async (route, context) => {
    const {
      paginate
    } = route;

    if (!paginate) {
      throw new Error('Route missing paginate');
    }

    const shouldRenderItemPage = hasItemPageConfig(route);
    const shouldRenderListPage = hasListPageConfig(paginate);

    try {
      const paginatedData = await getPaginatedData(generateContext, paginate, context);

      if (!paginatedData) {
        return [];
      }

      const totalPages = calculatePages(paginatedData.total, paginate.pageSize);
      const routeContext = {
        pathPrefix,
        totalPages,
        renderTemplate,
        route,
        context
      };
      const pages = [];

      const writePages = () => (0, _streams.createAsyncWritable)(async args => {
        pages.push((await renderTemplate.apply(null, args)));
      }, 100);

      const writeStreams = [];

      if (shouldRenderItemPage) {
        writeStreams.push(new _pumpify.obj((0, _streams2.createItemRenderArgs)(routeContext, _context.getItemContext, stats), writePages()));
      }

      if (shouldRenderListPage) {
        writeStreams.push(new _pumpify.obj((0, _streams2.createListRenderArgs)(routeContext, _context.getListPageContext), writePages()));
      }

      const data = _asyncIteratorToStream.default.obj(paginatedData.iterable);

      await _bluebird.default.map(writeStreams, writeStream => (0, _streams.pump)(data, writeStream));
      return pages;
    } catch (e) {
      if (e instanceof _graphqlError.default || e instanceof _paginationError.default) {
        throw e;
      }

      throw new Error(`Failed to render paginated route ${route.path}\n ${e.name}: ${e.message}`);
    }
  };
}

async function resolveRouteContext(generateContext, route) {
  const {
    srcPath,
    connector,
    fileLoader,
    stats
  } = generateContext;
  const contextConfig = route.context;
  return contextConfig ? (0, _resolveContext.default)({
    contextConfig,
    srcPath,
    connector,
    fileLoader,
    stats,
    route
  }) : {};
}

function renderTemplates(generateContext) {
  const {
    renderTemplate,
    config,
    globalContext,
    pathPrefix
  } = generateContext;
  return routes => _bluebird.default.map(routes, async route => {
    const routeContext = await resolveRouteContext(generateContext, route);
    const context = (0, _context.combineContext)(config.env, globalContext, route, routeContext);
    const path = (0, _paths.joinPath)(pathPrefix, route.path);
    return renderTemplate(path, route.template, context);
  });
}

function renderPaginatedTemplates(generateContext) {
  const render = renderPaginatedTemplate(generateContext, getPaginatedData);
  return async routes => {
    const {
      config,
      globalContext
    } = generateContext;
    const pages = await _bluebird.default.map(routes, async route => {
      const routeContext = await resolveRouteContext(generateContext, route);
      return render(route, (0, _context.combineContext)(config.env, globalContext, route, routeContext));
    });
    return (0, _flatten.default)(pages);
  };
}

async function generatePages(config, generateContext) {
  const [paginatedRoutes, singleRoutes] = (0, _partition.default)((0, _values.default)(config.routes), 'paginate');
  const renderContext = { ...generateContext,
    globalContext: { ...(config.context ? await (0, _resolveContext.default)({
        contextConfig: config.context,
        srcPath: generateContext.srcPath,
        connector: generateContext.connector,
        fileLoader: generateContext.fileLoader,
        stats: generateContext.stats
      }) : {}),
      locale: config.locale
    }
  };
  const singlePages = await renderTemplates(renderContext)(singleRoutes);
  const paginatedPages = await renderPaginatedTemplates(renderContext)(paginatedRoutes);
  return singlePages.concat(paginatedPages);
}

function removeListingPageConfig(routeConfig) {
  if (routeConfig.paginate) {
    const {
      template,
      ...rest
    } = routeConfig.paginate;

    if (template) {
      return { ...routeConfig,
        paginate: { ...rest
        }
      };
    }
  }

  return routeConfig;
}

async function generateRoute(config, params) {
  const {
    connector,
    fileLoader,
    templateFileLoader,
    routeName,
    locale,
    contentId
  } = params;
  const srcPath = config.templatePath;
  const stats = {
    pagesGenerated: 0,
    warnings: []
  };

  if (config.usageStats) {
    stats.contentUsage = {};
  }

  const clientSchema = await (0, _graphql.getClientSchema)(connector);
  const {
    locales
  } = config;
  const localizedConfig = locales && locale && locales[locale] ? (0, _config.localizeConfig)(config, locale) : config;
  const routeConfig = config.routes[routeName];

  if (!routeConfig) {
    return {
      pages: [],
      stats
    };
  }

  const globalContext = config.context ? await (0, _resolveContext.default)({
    contextConfig: config.context,
    srcPath,
    connector,
    fileLoader,
    stats
  }) : {};
  const renderContext = {
    renderTemplate: (0, _nunjucks.default)(templateFileLoader, localizedConfig, stats),
    pathPrefix: localizedConfig.pathPrefix || '',
    fileLoader,
    connector: (0, _graphql.withQueryTransforms)(connector, clientSchema, {
      locale,
      contentId,
      usage: config.usageStats
    }),
    clientSchema,
    srcPath,
    stats,
    config,
    globalContext
  };
  const pages = await (routeConfig.paginate ? renderPaginatedTemplates(renderContext)([removeListingPageConfig(routeConfig)]) : renderTemplates(renderContext)([routeConfig]));
  return {
    pages,
    stats
  };
}

const identity = obj => obj;

function getRenderTemplateDecorator(config) {
  var _config$htmlCompressi;

  const decorators = [];

  if (config.gzip) {
    decorators.push(_gzip.default);
  }

  if ((_config$htmlCompressi = config.htmlCompression) === null || _config$htmlCompressi === void 0 ? void 0 : _config$htmlCompressi.enabled) {
    decorators.push((0, _compressHtml.default)(config.htmlCompression));
  }

  return decorators.length ? (0, _compose.default)(decorators) : identity;
}

async function generate(config, params) {
  const {
    connector,
    fileLoader,
    templateFileLoader
  } = params;
  const srcPath = config.templatePath;
  const stats = {
    pagesGenerated: 0,
    warnings: []
  };

  if (config.usageStats) {
    stats.contentUsage = {};
  }

  const clientSchema = await (0, _graphql.getClientSchema)(connector);
  const generateContext = {
    pathPrefix: '',
    clientSchema,
    srcPath,
    stats,
    config,
    fileLoader
  };
  let pages;
  const renderTemplateDecorator = getRenderTemplateDecorator(config);
  const {
    locales
  } = config;

  if (locales) {
    const localizedPages = await _bluebird.default.map(Object.keys(locales), locale => {
      const localizedConfig = (0, _config.localizeConfig)(config, locale);
      return generatePages(localizedConfig, { ...generateContext,
        renderTemplate: renderTemplateDecorator((0, _nunjucks.default)(templateFileLoader, localizedConfig, stats)),
        pathPrefix: localizedConfig.pathPrefix,
        connector: (0, _graphql.withQueryTransforms)(connector, clientSchema, {
          locale,
          usage: config.usageStats
        })
      });
    });
    pages = (0, _flatten.default)(localizedPages);
  } else {
    pages = await generatePages(config, { ...generateContext,
      renderTemplate: renderTemplateDecorator((0, _nunjucks.default)(templateFileLoader, config, stats)),
      connector: (0, _graphql.withQueryTransforms)(connector, clientSchema, {
        usage: config.usageStats
      })
    });
  }

  return {
    pages,
    stats
  };
}