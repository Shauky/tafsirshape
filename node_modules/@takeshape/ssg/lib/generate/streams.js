"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readPageBuffer = readPageBuffer;
exports.createItemRenderArgs = createItemRenderArgs;
exports.createListRenderArgs = createListRenderArgs;

var _paths = require("../paths");

var _routing = require("@takeshape/routing");

var _stream = require("stream");

var _stats = require("../stats");

function readPageBuffer(buffer, last) {
  const {
    length
  } = buffer;
  const offset = length === 1 || length < 3 && !last ? -1 : 0;
  return {
    previous: buffer[offset],
    current: buffer[1 + offset],
    next: buffer[2 + offset]
  };
}

function handlePathWarnings(stats, warnings, route) {
  warnings.forEach(variable => {
    (0, _stats.generateWarning)(stats, 'renderPaginatedTemplate', `${route.path} variable ${variable} resolves to undefined.`);
  });
}

function createItemRenderArgs(routeContext, getItemContext, stats) {
  const {
    route,
    context,
    pathPrefix
  } = routeContext;
  const buffer = [];

  const createArgs = last => {
    const itemContext = getItemContext(route, context, readPageBuffer(buffer, last));
    return [itemContext.currentPath, route.template, itemContext];
  };

  return new _stream.Transform({
    objectMode: true,

    transform(obj, encoding, next) {
      const {
        path,
        warnings
      } = (0, _routing.formatPath)(route.path, obj);
      const currentPath = (0, _paths.joinPath)(pathPrefix, path);

      if (warnings.length) {
        handlePathWarnings(stats, warnings, route);
      } else {
        buffer.push({
          item: obj,
          path: currentPath
        });

        if (buffer.length > 1) {
          this.push(createArgs(false));

          if (buffer.length > 2) {
            buffer.shift();
          }
        }

        (0, _stats.recordContentUsage)(stats, obj, currentPath);
      }

      next();
    },

    flush(done) {
      if (buffer.length) {
        this.push(createArgs(true));
      }

      done();
    }

  });
}

function createListRenderArgs(routeContext, getListPageContext) {
  const {
    pathPrefix,
    route
  } = routeContext;
  const {
    paginate
  } = route;

  if (!paginate) {
    throw new Error('Cannot create list page for non-paginated route');
  }

  const {
    template,
    pageSize
  } = paginate;

  if (!template) {
    throw new Error('Cannot create list page missing paginate.template');
  }

  let buffer = [];
  let page = 1;

  const createArgs = () => {
    const context = getListPageContext(buffer, page, routeContext);
    page++;
    buffer = [];
    return [(0, _paths.joinPath)(pathPrefix, context.currentPath), template, context];
  };

  return new _stream.Transform({
    objectMode: true,

    transform(obj, encoding, next) {
      buffer.push(obj);

      if (buffer.length === pageSize) {
        this.push(createArgs());
      }

      next();
    },

    flush(done) {
      if (buffer.length) {
        this.push(createArgs());
      }

      done();
    }

  });
}