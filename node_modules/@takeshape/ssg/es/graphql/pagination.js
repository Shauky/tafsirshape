import '../async-iterator-polyfill';
import { createArgument, createVariableDefinition, createField, createSelectionSet } from './ast';
import keyBy from 'lodash/keyBy';
import get from 'lodash/get';
import { updateIn } from '../util';
import { parse, visit, print, visitWithTypeInfo, TypeInfo } from 'graphql';
import GraphQLError from '../errors/graphql-error';
import PaginationError from '../errors/pagination-error';
const paginationStrategies = [{
  type: 'cursor',
  fromName: 'after',
  sizeName: 'first',
  hasNextPath: ['pageInfo', 'hasNextPage'],
  cursorPath: ['pageInfo', 'endCursor'],
  itemsPath: ['items']
}, {
  type: 'offset',
  fromName: 'from',
  sizeName: 'size',
  totalPath: ['total'],
  itemsPath: ['items']
}, {
  type: 'offset',
  fromName: 'offset',
  sizeName: 'limit',
  totalPath: ['total'],
  itemsPath: ['items']
}];

function getPaginationStrategy(fieldDef) {
  if (fieldDef) {
    const {
      args
    } = fieldDef;

    if (args && args.length) {
      const keyedArgs = keyBy(args, 'name');
      return paginationStrategies.find(strategy => {
        const {
          fromName,
          sizeName
        } = strategy;
        return keyedArgs[fromName] && keyedArgs[sizeName];
      });
    }
  }
}

function getVariableName(path, name) {
  return path.concat([name]).join('_');
}

export function findPaginatedFields(ast, schema) {
  const typeInfo = new TypeInfo(schema);
  const result = [];
  const queryPath = [];
  const visitor = {
    Field: {
      enter(node, key, parent, path) {
        queryPath.push(node.alias ? node.alias.value : node.name.value);
        const fieldDef = typeInfo.getFieldDef();
        const strategy = getPaginationStrategy(fieldDef);

        if (strategy) {
          result.push({
            strategy,
            fromVarName: getVariableName(queryPath, strategy.fromName),
            sizeVarName: getVariableName(queryPath, strategy.sizeName),
            astPath: path.map(String),
            queryPath: queryPath.slice()
          }); // skip child nodes

          queryPath.pop();
          return false;
        }
      },

      leave() {
        queryPath.pop();
      }

    }
  };
  visit(ast, visitWithTypeInfo(typeInfo, visitor));
  return result;
}
export function removeNonPaginated(ast, paginatedFields) {
  const paths = new Set();

  for (const field of paginatedFields) {
    paths.add(field.astPath.join('.'));
  }

  const visitor = {
    Field: {
      enter(node, key, parent, path) {
        return paths.has(path.join('.')) ? false : null;
      }

    }
  };
  return visit(ast, visitor);
}
export function addPaginationVariables(ast, paginatedFields) {
  const variablesToReplace = Object.create(null);
  const variables = [];

  for (const paginatedField of paginatedFields) {
    const {
      fromVarName,
      sizeVarName,
      strategy
    } = paginatedField;
    const {
      sizeName,
      fromName
    } = strategy;
    updateIn(ast, paginatedField.astPath, field => {
      const newField = { ...field
      };

      if (field.arguments) {
        newField.arguments = field.arguments.filter(arg => {
          const name = arg.name.value;

          if (name === sizeName || name === fromName) {
            if (arg.value.kind === 'Variable') {
              variablesToReplace[arg.value.name.value] = true;
            }

            return false;
          }

          return true;
        });
        newField.arguments.push(createArgument({
          name: fromName,
          value: fromVarName
        }));
        newField.arguments.push(createArgument({
          name: sizeName,
          value: sizeVarName
        }));
      }

      variables.push({
        name: fromVarName,
        type: paginatedField.strategy.type === 'cursor' ? 'String' : 'Int'
      });
      variables.push({
        name: sizeVarName,
        type: 'Int'
      });
      return newField;
    });
  }

  const queryPath = paginatedFields[0].astPath.slice(0, 2);
  updateIn(ast, queryPath, query => {
    if (query.variableDefinitions) {
      query.variableDefinitions = query.variableDefinitions.filter(def => !variablesToReplace[def.variable.name.value]).concat(variables.map(createVariableDefinition));
    }

    return query;
  });
  return ast;
}
export function hasField(ast, queryPath) {
  let node = ast;

  for (const name of queryPath) {
    if (!node.selectionSet) {
      return false;
    }

    const field = node.selectionSet.selections.find(selection => selection.kind === 'Field' && selection.name.value === name);

    if (field) {
      node = field;
    } else {
      return false;
    }
  }

  return true;
}
export function ensureField(ast, queryPath) {
  let node = ast;

  for (const name of queryPath) {
    if (node.selectionSet) {
      let {
        selections
      } = node.selectionSet;
      const field = selections.find(selection => selection.kind === 'Field' && selection.name.value === name);

      if (field) {
        node = field;
      } else {
        selections = selections.concat([createField(name)]);
        node.selectionSet.selections = selections;
        node = selections[selections.length - 1];
      }
    } else {
      node.selectionSet = createSelectionSet([createField(name)]);
      node = node.selectionSet.selections[0];
    }
  }

  return ast;
}
export function ensurePaginationFields(ast, paginatedFields, source = '') {
  for (const paginatedField of paginatedFields) {
    const {
      strategy,
      astPath,
      queryPath
    } = paginatedField;
    const {
      type
    } = strategy;
    const field = get(ast, astPath);

    if (!hasField(field, strategy.itemsPath)) {
      const missingPath = queryPath.concat(strategy.itemsPath).join('.');
      throw new PaginationError(`Expected ${missingPath} to be specified: ${source}`);
    }

    if (type === 'cursor' && strategy.hasNextPath && strategy.cursorPath) {
      ensureField(field, strategy.hasNextPath);
      ensureField(field, strategy.cursorPath);
    } else if (strategy.totalPath) {
      ensureField(field, strategy.totalPath);
    }
  }

  return ast;
}
export function isDone(queryArgs, queryData, paginatedField) {
  const {
    strategy,
    queryPath,
    fromVarName,
    sizeVarName
  } = paginatedField;
  const {
    hasNextPath,
    totalPath
  } = strategy;

  if (hasNextPath) {
    return !get(queryData, queryPath.concat(hasNextPath));
  }

  if (totalPath) {
    return queryArgs[fromVarName] + queryArgs[sizeVarName] >= get(queryData, queryPath.concat(totalPath));
  }

  throw Error('Invalid pagination strategy');
}

function incrementVariables(variables, data, paginatedField) {
  const {
    strategy,
    queryPath,
    fromVarName,
    sizeVarName
  } = paginatedField;
  const {
    cursorPath,
    type
  } = strategy;

  if (type === 'cursor' && cursorPath) {
    variables[fromVarName] = get(data, queryPath.concat(cursorPath));
  } else {
    variables[fromVarName] += variables[sizeVarName];
  }
}

function handleErrors(res, source) {
  if (res.errors) {
    throw new GraphQLError(`An error occurred ${source}`, res.errors);
  }
}

export async function getQueryIterator(schema, query, connector, {
  variables,
  pageSize = 100,
  source,
  stats
} = {}) {
  const queryAst = parse(query);
  const paginatedFields = findPaginatedFields(queryAst, schema);

  if (paginatedFields.length !== 1) {
    throw new PaginationError(`No paginated fields: ${source}`);
  }

  const astWithVars = addPaginationVariables(queryAst, paginatedFields);
  const astNormalized = ensurePaginationFields(astWithVars, paginatedFields, source);
  const queryWithVars = print(astNormalized);
  const vars = { ...variables
  }; // initialize pagination vars

  const paginatedField = paginatedFields[0];

  if (paginatedField.strategy.type === 'offset') {
    vars[paginatedField.fromVarName] = 0;
  }

  vars[paginatedField.sizeVarName] = pageSize;
  const itemsPath = paginatedField.queryPath.concat(paginatedField.strategy.itemsPath);
  let total;
  let first;
  const connectorContext = {
    source,
    stats,
    applyMigrations: false,
    isPaginated: true
  };

  if (paginatedField.strategy.type === 'offset' && paginatedField.strategy.totalPath) {
    const totalPath = paginatedField.queryPath.concat(paginatedField.strategy.totalPath);
    first = await connector({
      query: queryWithVars,
      variables: vars
    }, connectorContext);
    handleErrors(first, source);
    total = get(first.data, totalPath);
  }

  const iterator = async function* () {
    while (true) {
      // eslint-disable-next-line no-await-in-loop
      const res = first || (await connector({
        query: queryWithVars,
        variables: vars
      }, connectorContext));

      if (first) {
        first = null;
      }

      handleErrors(res, source);
      const data = res.data;

      for (const item of get(data, itemsPath).filter(Boolean)) {
        yield item;
      }

      if (isDone(vars, data, paginatedField)) {
        break;
      }

      incrementVariables(vars, data, paginatedField);
    }
  };

  return {
    total,
    iterator
  };
}