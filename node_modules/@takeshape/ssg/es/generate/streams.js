import { joinPath } from '../paths';
import { formatPath } from '@takeshape/routing';
export function readPageBuffer(buffer, last) {
  const {
    length
  } = buffer;
  const offset = length === 1 || length < 3 && !last ? -1 : 0;
  return {
    previous: buffer[offset],
    current: buffer[1 + offset],
    next: buffer[2 + offset]
  };
}
import { Transform } from 'stream';
import { generateWarning, recordContentUsage } from '../stats';

function handlePathWarnings(stats, warnings, route) {
  warnings.forEach(variable => {
    generateWarning(stats, 'renderPaginatedTemplate', `${route.path} variable ${variable} resolves to undefined.`);
  });
}

export function createItemRenderArgs(routeContext, getItemContext, stats) {
  const {
    route,
    context,
    pathPrefix
  } = routeContext;
  const buffer = [];

  const createArgs = last => {
    const itemContext = getItemContext(route, context, readPageBuffer(buffer, last));
    return [itemContext.currentPath, route.template, itemContext];
  };

  return new Transform({
    objectMode: true,

    transform(obj, encoding, next) {
      const {
        path,
        warnings
      } = formatPath(route.path, obj);
      const currentPath = joinPath(pathPrefix, path);

      if (warnings.length) {
        handlePathWarnings(stats, warnings, route);
      } else {
        buffer.push({
          item: obj,
          path: currentPath
        });

        if (buffer.length > 1) {
          this.push(createArgs(false));

          if (buffer.length > 2) {
            buffer.shift();
          }
        }

        recordContentUsage(stats, obj, currentPath);
      }

      next();
    },

    flush(done) {
      if (buffer.length) {
        this.push(createArgs(true));
      }

      done();
    }

  });
}
export function createListRenderArgs(routeContext, getListPageContext) {
  const {
    pathPrefix,
    route
  } = routeContext;
  const {
    paginate
  } = route;

  if (!paginate) {
    throw new Error('Cannot create list page for non-paginated route');
  }

  const {
    template,
    pageSize
  } = paginate;

  if (!template) {
    throw new Error('Cannot create list page missing paginate.template');
  }

  let buffer = [];
  let page = 1;

  const createArgs = () => {
    const context = getListPageContext(buffer, page, routeContext);
    page++;
    buffer = [];
    return [joinPath(pathPrefix, context.currentPath), template, context];
  };

  return new Transform({
    objectMode: true,

    transform(obj, encoding, next) {
      buffer.push(obj);

      if (buffer.length === pageSize) {
        this.push(createArgs());
      }

      next();
    },

    flush(done) {
      if (buffer.length) {
        this.push(createArgs());
      }

      done();
    }

  });
}