import '../async-iterator-polyfill';
import BbPromise from 'bluebird';
import resolveContext, { resolveGraphQLConfig } from '../resolve-context';
import { getClientSchema, getQueryIterator, withQueryTransforms } from '../graphql';
import nunjucks from '../nunjucks';
import compressHtml from '../compress-html';
import { joinPath } from '../paths';
import GraphQLError from '../errors/graphql-error';
import PaginationError from '../errors/pagination-error';
import flatten from 'lodash/fp/flatten';
import partition from 'lodash/partition';
import values from 'lodash/values';
import { createAsyncWritable, pump } from '@takeshape/streams';
import { createItemRenderArgs, createListRenderArgs } from './streams';
import { combineContext, getItemContext, getListPageContext } from './context';
import { localizeConfig } from '../config';
import asyncIteratorToStream from 'async-iterator-to-stream';
import { obj as Pumpify } from 'pumpify';
import compose from 'lodash/fp/compose';
import gzipContents from '../gzip';
const pageSize = Number(process.env.TS_EXPERIMENTAL_PAGE_SIZE) || 100;

const getPaginatedData = async (generateContext, paginate, context) => {
  const {
    connector,
    fileLoader,
    srcPath,
    clientSchema,
    stats
  } = generateContext;

  if (paginate.data) {
    const config = await resolveGraphQLConfig(paginate.data, {
      fileLoader,
      srcPath
    });
    const res = await getQueryIterator(clientSchema, config.query, connector, {
      pageSize,
      variables: config.variables,
      source: config.source,
      stats
    });
    return {
      iterable: res.iterator(),
      total: res.total
    };
  }

  if (paginate.property) {
    const itemsArray = context[paginate.property];

    if (itemsArray) {
      const filtered = itemsArray.filter(Boolean);
      return {
        iterable: filtered,
        total: filtered.length
      };
    }
  }

  return null;
};

export function calculatePages(total, pageSize) {
  return Math.ceil(total / pageSize);
}
export function hasListPageConfig(paginate) {
  return Boolean(paginate.pageSize && paginate.template && paginate.path);
}
export function hasItemPageConfig(route) {
  return Boolean(route.path && route.template);
}
export function renderPaginatedTemplate(generateContext, getPaginatedData) {
  const {
    renderTemplate,
    stats,
    pathPrefix
  } = generateContext;
  return async (route, context) => {
    const {
      paginate
    } = route;

    if (!paginate) {
      throw new Error('Route missing paginate');
    }

    const shouldRenderItemPage = hasItemPageConfig(route);
    const shouldRenderListPage = hasListPageConfig(paginate);

    try {
      const paginatedData = await getPaginatedData(generateContext, paginate, context);

      if (!paginatedData) {
        return [];
      }

      const totalPages = calculatePages(paginatedData.total, paginate.pageSize);
      const routeContext = {
        pathPrefix,
        totalPages,
        renderTemplate,
        route,
        context
      };
      const pages = [];

      const writePages = () => createAsyncWritable(async args => {
        pages.push((await renderTemplate.apply(null, args)));
      }, 100);

      const writeStreams = [];

      if (shouldRenderItemPage) {
        writeStreams.push(new Pumpify(createItemRenderArgs(routeContext, getItemContext, stats), writePages()));
      }

      if (shouldRenderListPage) {
        writeStreams.push(new Pumpify(createListRenderArgs(routeContext, getListPageContext), writePages()));
      }

      const data = asyncIteratorToStream.obj(paginatedData.iterable);
      await BbPromise.map(writeStreams, writeStream => pump(data, writeStream));
      return pages;
    } catch (e) {
      if (e instanceof GraphQLError || e instanceof PaginationError) {
        throw e;
      }

      throw new Error(`Failed to render paginated route ${route.path}\n ${e.name}: ${e.message}`);
    }
  };
}

async function resolveRouteContext(generateContext, route) {
  const {
    srcPath,
    connector,
    fileLoader,
    stats
  } = generateContext;
  const contextConfig = route.context;
  return contextConfig ? resolveContext({
    contextConfig,
    srcPath,
    connector,
    fileLoader,
    stats,
    route
  }) : {};
}

function renderTemplates(generateContext) {
  const {
    renderTemplate,
    config,
    globalContext,
    pathPrefix
  } = generateContext;
  return routes => BbPromise.map(routes, async route => {
    const routeContext = await resolveRouteContext(generateContext, route);
    const context = combineContext(config.env, globalContext, route, routeContext);
    const path = joinPath(pathPrefix, route.path);
    return renderTemplate(path, route.template, context);
  });
}

function renderPaginatedTemplates(generateContext) {
  const render = renderPaginatedTemplate(generateContext, getPaginatedData);
  return async routes => {
    const {
      config,
      globalContext
    } = generateContext;
    const pages = await BbPromise.map(routes, async route => {
      const routeContext = await resolveRouteContext(generateContext, route);
      return render(route, combineContext(config.env, globalContext, route, routeContext));
    });
    return flatten(pages);
  };
}

async function generatePages(config, generateContext) {
  const [paginatedRoutes, singleRoutes] = partition(values(config.routes), 'paginate');
  const renderContext = { ...generateContext,
    globalContext: { ...(config.context ? await resolveContext({
        contextConfig: config.context,
        srcPath: generateContext.srcPath,
        connector: generateContext.connector,
        fileLoader: generateContext.fileLoader,
        stats: generateContext.stats
      }) : {}),
      locale: config.locale
    }
  };
  const singlePages = await renderTemplates(renderContext)(singleRoutes);
  const paginatedPages = await renderPaginatedTemplates(renderContext)(paginatedRoutes);
  return singlePages.concat(paginatedPages);
}

function removeListingPageConfig(routeConfig) {
  if (routeConfig.paginate) {
    const {
      template,
      ...rest
    } = routeConfig.paginate;

    if (template) {
      return { ...routeConfig,
        paginate: { ...rest
        }
      };
    }
  }

  return routeConfig;
}

export async function generateRoute(config, params) {
  const {
    connector,
    fileLoader,
    templateFileLoader,
    routeName,
    locale,
    contentId
  } = params;
  const srcPath = config.templatePath;
  const stats = {
    pagesGenerated: 0,
    warnings: []
  };

  if (config.usageStats) {
    stats.contentUsage = {};
  }

  const clientSchema = await getClientSchema(connector);
  const {
    locales
  } = config;
  const localizedConfig = locales && locale && locales[locale] ? localizeConfig(config, locale) : config;
  const routeConfig = config.routes[routeName];

  if (!routeConfig) {
    return {
      pages: [],
      stats
    };
  }

  const globalContext = config.context ? await resolveContext({
    contextConfig: config.context,
    srcPath,
    connector,
    fileLoader,
    stats
  }) : {};
  const renderContext = {
    renderTemplate: nunjucks(templateFileLoader, localizedConfig, stats),
    pathPrefix: localizedConfig.pathPrefix || '',
    fileLoader,
    connector: withQueryTransforms(connector, clientSchema, {
      locale,
      contentId,
      usage: config.usageStats
    }),
    clientSchema,
    srcPath,
    stats,
    config,
    globalContext
  };
  const pages = await (routeConfig.paginate ? renderPaginatedTemplates(renderContext)([removeListingPageConfig(routeConfig)]) : renderTemplates(renderContext)([routeConfig]));
  return {
    pages,
    stats
  };
}

const identity = obj => obj;

function getRenderTemplateDecorator(config) {
  var _config$htmlCompressi;

  const decorators = [];

  if (config.gzip) {
    decorators.push(gzipContents);
  }

  if ((_config$htmlCompressi = config.htmlCompression) === null || _config$htmlCompressi === void 0 ? void 0 : _config$htmlCompressi.enabled) {
    decorators.push(compressHtml(config.htmlCompression));
  }

  return decorators.length ? compose(decorators) : identity;
}

export default async function generate(config, params) {
  const {
    connector,
    fileLoader,
    templateFileLoader
  } = params;
  const srcPath = config.templatePath;
  const stats = {
    pagesGenerated: 0,
    warnings: []
  };

  if (config.usageStats) {
    stats.contentUsage = {};
  }

  const clientSchema = await getClientSchema(connector);
  const generateContext = {
    pathPrefix: '',
    clientSchema,
    srcPath,
    stats,
    config,
    fileLoader
  };
  let pages;
  const renderTemplateDecorator = getRenderTemplateDecorator(config);
  const {
    locales
  } = config;

  if (locales) {
    const localizedPages = await BbPromise.map(Object.keys(locales), locale => {
      const localizedConfig = localizeConfig(config, locale);
      return generatePages(localizedConfig, { ...generateContext,
        renderTemplate: renderTemplateDecorator(nunjucks(templateFileLoader, localizedConfig, stats)),
        pathPrefix: localizedConfig.pathPrefix,
        connector: withQueryTransforms(connector, clientSchema, {
          locale,
          usage: config.usageStats
        })
      });
    });
    pages = flatten(localizedPages);
  } else {
    pages = await generatePages(config, { ...generateContext,
      renderTemplate: renderTemplateDecorator(nunjucks(templateFileLoader, config, stats)),
      connector: withQueryTransforms(connector, clientSchema, {
        usage: config.usageStats
      })
    });
  }

  return {
    pages,
    stats
  };
}