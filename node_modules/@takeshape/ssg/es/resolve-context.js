import BbPromise from 'bluebird';
import forEach from 'lodash/forEach';
import yaml from 'js-yaml';
import path from 'path';
import GraphQLError from './errors/graphql-error';
import { recordContentUsage } from './stats';
import { isGraphQLQueryConfig } from './config';
export function getType(path) {
  const matches = /\.(graphql|yml|yaml|json)$/.exec(path);

  if (matches && matches.length) {
    const type = matches[1];
    return type === 'yml' ? 'yaml' : type;
  }

  return null;
}

function getPath(contextConfig) {
  if (typeof contextConfig === 'string') {
    return contextConfig;
  }

  if (isGraphQLQueryConfig(contextConfig)) {
    return contextConfig.query;
  }

  throw new Error('Unable to find file path in context config');
}

export function handleJSON({
  srcPath,
  filePath,
  fileLoader
}) {
  return fileLoader(path.join(srcPath, filePath)).then(JSON.parse);
}
export function handleYaml({
  srcPath,
  filePath,
  fileLoader
}) {
  return fileLoader(path.join(srcPath, filePath)).then(yaml.safeLoad);
}
export async function handleGraphQL({
  srcPath,
  filePath,
  variables,
  connector,
  fileLoader,
  route,
  stats
}) {
  const queryPath = path.join(srcPath, filePath);
  const query = await fileLoader(queryPath);
  const res = await connector({
    query,
    variables
  }, {
    stats,
    source: filePath
  });

  if (res.errors) {
    throw new GraphQLError(`An error occurred while resolving ${queryPath}`, res.errors);
  }

  const data = res.data;

  if (route && route.path && !route.paginate) {
    recordContentUsage(stats, data, route.path);
  }

  return data;
}
export async function handleContextString(params) {
  const {
    contextConfig,
    ...rest
  } = params;
  const filePath = getPath(contextConfig);
  const type = getType(filePath);

  if (type === 'json') {
    return handleJSON({ ...rest,
      filePath
    });
  }

  if (type === 'yaml') {
    return handleYaml({ ...rest,
      filePath
    });
  }

  if (type === 'graphql') {
    return handleGraphQL({ ...rest,
      filePath
    });
  }

  return filePath;
}
export async function resolveGraphQLConfig(config, {
  fileLoader,
  srcPath
}) {
  let source;
  let variables;

  if (typeof config === 'string') {
    source = config;
  } else if (isGraphQLQueryConfig(config)) {
    source = config.query;
    variables = config.variables;
  }

  if (!source) {
    throw new Error('Missing .graphql or .gql query file');
  }

  const filePath = path.join(srcPath, source);
  const query = await fileLoader(filePath);
  return {
    source,
    query,
    variables
  };
}

function handleValue(contextParams) {
  const {
    contextConfig,
    ...rest
  } = contextParams;

  if (typeof contextConfig === 'string') {
    return handleContextString(contextParams);
  }

  if (typeof contextConfig === 'object') {
    if (isGraphQLQueryConfig(contextConfig)) {
      return handleGraphQL({ ...rest,
        filePath: contextConfig.query,
        variables: contextConfig.variables
      });
    }

    const context = {};
    forEach(contextConfig, (value, key) => {
      context[key] = handleValue({ ...rest,
        contextConfig: value
      });
    });
    return BbPromise.props(context);
  }

  return contextConfig;
}

function isObject(obj) {
  return Boolean(obj) && typeof obj === 'object' && !Array.isArray(obj);
}

export default async function resolveContext(contextParams) {
  const context = await handleValue(contextParams);
  return isObject(context) ? context : {};
}