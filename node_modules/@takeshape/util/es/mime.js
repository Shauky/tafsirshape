import mime from 'mime-types';
const compressedMimeTypes = new Set(['application/atom+xml', 'application/javascript', 'application/json', 'application/ld+json', 'application/manifest+json', 'application/rdf+xml', 'application/rss+xml', 'application/schema+json', 'application/vnd.geo+json', 'application/vnd.ms-fontobject', 'application/x-font-ttf', 'application/x-javascript', 'application/x-web-app-manifest+json', 'application/xhtml+xml', 'application/xml', 'font/eot', 'font/otf', 'font/opentype', 'image/bmp', 'image/svg+xml', 'image/vnd.microsoft.icon', 'image/x-icon', 'text/cache-manifest', 'text/css', 'text/html', 'text/javascript', 'text/plain', 'text/vcard', 'text/vnd.rim.location.xloc', 'text/vtt', 'text/x-component', 'text/x-cross-domain-policy', 'text/xml']); // application/octetstream

const DEFAULT_TYPE = mime.lookup('bin');
/**
 * Gets the content type of the file, based on it's extension.
 * @param  {String} src Path to file fow which content type should be evaluated.
 * @return {String}     Returns string with content type and charset.
 */

export function contentType(src) {
  let type = (mime.lookup(src) || DEFAULT_TYPE).replace('-', '');
  const charset = mime.charset(type);

  if (charset) {
    type += '; charset=' + charset;
  }

  return type;
}
/**
 * Determines whether we should compress based on file extension
 * @param  {String} src Path to file fow which content type should be evaluated.
 * @return {Boolean}    Returns true if we should compress
 */

export function shouldCompress(src) {
  const mimeType = mime.lookup(src);
  return Boolean(mimeType && compressedMimeTypes.has(mimeType));
}