"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.streamToPromise = streamToPromise;
exports.createTransform = createTransform;
exports.createFilter = createFilter;
exports.readStreamToBuffer = readStreamToBuffer;
exports.collectStreamIntoArray = exports.readableFromArray = exports.tee = exports.createAsyncWritable = exports.createAccumulator = exports.pump = void 0;

var _stream = require("stream");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _pQueue = _interopRequireDefault(require("p-queue"));

var _isStream = _interopRequireDefault(require("is-stream"));

var _through = _interopRequireDefault(require("through2"));

var _pump = _interopRequireDefault(require("pump"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pump = _bluebird.default.promisify(_pump.default);

exports.pump = pump;

function streamToPromise(stream) {
  return new Promise((resolve, reject) => {
    const doneEvent = _isStream.default.writable(stream) ? 'finish' : 'end';
    stream.on('error', reject).on(doneEvent, resolve);
  });
}

function createTransform(transform) {
  return _through.default.obj(function (content, enc, callback) {
    try {
      this.push(transform(content));
      callback();
    } catch (e) {
      callback(e);
    }
  });
}

function createFilter(predicate) {
  return _through.default.obj(function (content, encoding, callback) {
    try {
      if (predicate(content)) {
        this.push(content);
      }

      callback();
    } catch (e) {
      callback(e);
    }
  });
}

const createAccumulator = accumulator => _through.default.obj(function (item, enc, cb) {
  // eslint-disable-line prefer-arrow-callback
  accumulator(item);
  cb(null, item);
});

exports.createAccumulator = createAccumulator;

const createAsyncWritable = (write, concurrency = 16) => {
  const queue = new _pQueue.default({
    concurrency
  });
  return new _stream.Writable({
    objectMode: true,

    write(data, enc, cb) {
      queue.add(() => write(data)).catch(error => this.emit('error', error));
      cb();
    },

    final(cb) {
      queue.onIdle().then(() => cb());
    }

  });
};

exports.createAsyncWritable = createAsyncWritable;

const tee = (...args) => {
  const first = args[0];
  const streams = Array.isArray(first) ? first : args;
  const donePromises = streams.map(streamToPromise);
  return new _stream.Writable({
    objectMode: true,

    write(data, enc, callback) {
      Promise.all(streams.map(stream => stream.write(data) || _bluebird.default.fromCallback(cb => stream.once('drain', cb)) // if .write() => false buffer is full, start promise to wait for drain event
      )).then(() => callback());
    },

    final(callback) {
      streams.forEach(stream => stream.end());
      Promise.all(donePromises).then(() => callback());
    }

  });
};

exports.tee = tee;

const readableFromArray = (array, options) => {
  let index = 0;
  return new _stream.Readable({
    objectMode: true,

    read() {
      this.push(index < array.length ? array[index] : null);
      index++;
    },

    ...options
  });
};

exports.readableFromArray = readableFromArray;

const collectStreamIntoArray = (array = [], options = {}) => new _stream.Writable({
  objectMode: true,

  writev(chunks, cb) {
    chunks.forEach(({
      chunk
    }) => array.push(chunk));
    cb(null);
  },

  ...options
});

exports.collectStreamIntoArray = collectStreamIntoArray;

async function readStreamToBuffer(stream) {
  const chunks = [];
  const writeStream = new _stream.PassThrough();
  writeStream.on('data', chunk => chunks.push(chunk));
  await pump(stream, writeStream);
  return Buffer.concat(chunks);
}