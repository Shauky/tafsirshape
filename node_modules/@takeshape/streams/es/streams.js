import { PassThrough, Readable, Writable } from 'stream';
import BBPromise from 'bluebird';
import PQueue from 'p-queue';
import isStream from 'is-stream';
import through2 from 'through2';
import basePump from 'pump';
export const pump = BBPromise.promisify(basePump);
export function streamToPromise(stream) {
  return new Promise((resolve, reject) => {
    const doneEvent = isStream.writable(stream) ? 'finish' : 'end';
    stream.on('error', reject).on(doneEvent, resolve);
  });
}
export function createTransform(transform) {
  return through2.obj(function (content, enc, callback) {
    try {
      this.push(transform(content));
      callback();
    } catch (e) {
      callback(e);
    }
  });
}
export function createFilter(predicate) {
  return through2.obj(function (content, encoding, callback) {
    try {
      if (predicate(content)) {
        this.push(content);
      }

      callback();
    } catch (e) {
      callback(e);
    }
  });
}
export const createAccumulator = accumulator => through2.obj(function (item, enc, cb) {
  // eslint-disable-line prefer-arrow-callback
  accumulator(item);
  cb(null, item);
});
export const createAsyncWritable = (write, concurrency = 16) => {
  const queue = new PQueue({
    concurrency
  });
  return new Writable({
    objectMode: true,

    write(data, enc, cb) {
      queue.add(() => write(data)).catch(error => this.emit('error', error));
      cb();
    },

    final(cb) {
      queue.onIdle().then(() => cb());
    }

  });
};
export const tee = (...args) => {
  const first = args[0];
  const streams = Array.isArray(first) ? first : args;
  const donePromises = streams.map(streamToPromise);
  return new Writable({
    objectMode: true,

    write(data, enc, callback) {
      Promise.all(streams.map(stream => stream.write(data) || BBPromise.fromCallback(cb => stream.once('drain', cb)) // if .write() => false buffer is full, start promise to wait for drain event
      )).then(() => callback());
    },

    final(callback) {
      streams.forEach(stream => stream.end());
      Promise.all(donePromises).then(() => callback());
    }

  });
};
export const readableFromArray = (array, options) => {
  let index = 0;
  return new Readable({
    objectMode: true,

    read() {
      this.push(index < array.length ? array[index] : null);
      index++;
    },

    ...options
  });
};
export const collectStreamIntoArray = (array = [], options = {}) => new Writable({
  objectMode: true,

  writev(chunks, cb) {
    chunks.forEach(({
      chunk
    }) => array.push(chunk));
    cb(null);
  },

  ...options
});
export async function readStreamToBuffer(stream) {
  const chunks = [];
  const writeStream = new PassThrough();
  writeStream.on('data', chunk => chunks.push(chunk));
  await pump(stream, writeStream);
  return Buffer.concat(chunks);
}